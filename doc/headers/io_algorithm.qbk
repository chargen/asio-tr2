[section Header [^<io_algorithm>] synopsis]

  namespace std {
    namespace tr2 {
      namespace sys {

        // completion conditions:
        class ``[link classes.transfer_all transfer_all]``;
        class ``[link classes.transfer_at_least transfer_at_least]``;

        // synchronous read operations:
        template<class SyncReadStream, class MutableBufferSequence>
          size_t read(SyncReadStream& stream,
                      const MutableBufferSequence& buffers);
        template<class SyncReadStream, class MutableBufferSequence>
          size_t read(SyncReadStream& stream,
                      const MutableBufferSequence& buffers, error_code& ec);
        template<class SyncReadStream, class MutableBufferSequence,
          class CompletionCondition>
            size_t read(SyncReadStream& stream,
                        const MutableBufferSequence& buffers,
                        CompletionCondition completion_condition);
        template<class SyncReadStream, class MutableBufferSequence,
          class CompletionCondition>
            size_t read(SyncReadStream& stream,
                        const MutableBufferSequence& buffers,
                        CompletionCondition completion_condition,
                        error_code& ec);
        template<class SyncReadStream, class Allocator>
          size_t read(SyncReadStream& stream, basic_fifobuf<Allocator>& sb);
        template<class SyncReadStream, class Allocator>
          size_t read(SyncReadStream& stream, basic_fifobuf<Allocator>& sb,
                      error_code& ec);
        template<class SyncReadStream, class Allocator,
          class CompletionCondition>
            size_t read(SyncReadStream& stream, basic_fifobuf<Allocator>& sb,
                        CompletionCondition completion_condition);
        template<class SyncReadStream, class Allocator,
          class CompletionCondition>
            size_t read(SyncReadStream& stream, basic_fifobuf<Allocator>& sb,
                        CompletionCondition completion_condition,
                        error_code& ec);

        // asynchronous read operations:
        template<class AsyncReadStream, class MutableBufferSequence,
          class ReadHandler>
            size_t async_read(AsyncReadStream& stream,
                              const MutableBufferSequence& buffers,
                              ReadHandler handler);
        template<class AsyncReadStream, class MutableBufferSequence,
          class CompletionCondition, class ReadHandler>
            size_t async_read(AsyncReadStream& stream,
                              const MutableBufferSequence& buffers,
                              CompletionCondition completion_condition,
                              ReadHandler handler);
        template<class AsyncReadStream, class Allocator, class ReadHandler>
          size_t async_read(AsyncReadStream& stream,
                            basic_fifobuf<Allocator>& sb,
                            ReadHandler handler);
        template<class AsyncReadStream, class Allocator,
          class CompletionCondition, class ReadHandler>
            size_t async_read(AsyncReadStream& stream,
                              basic_fifobuf<Allocator>& sb,
                              CompletionCondition completion_condition,
                              ReadHandler handler);

        // synchronous write operations:
        template<class SyncWriteStream, class ConstBufferSequence>
          size_t write(SyncWriteStream& stream,
                       const ConstBufferSequence& buffers);
        template<class SyncWriteStream, class ConstBufferSequence>
          size_t write(SyncWriteStream& stream,
                       const ConstBufferSequence& buffers, error_code& ec);
        template<class SyncWriteStream, class ConstBufferSequence,
          class CompletionCondition>
            size_t write(SyncWriteStream& stream,
                         const ConstBufferSequence& buffers,
                         CompletionCondition completion_condition);
        template<class SyncWriteStream, class ConstBufferSequence,
          class CompletionCondition>
            size_t write(SyncWriteStream& stream,
                         const ConstBufferSequence& buffers,
                         CompletionCondition completion_condition,
                         error_code& ec);
        template<class SyncWriteStream, class Allocator>
          size_t write(SyncWriteStream& stream, basic_fifobuf<Allocator>& sb);
        template<class SyncWriteStream, class Allocator>
          size_t write(SyncWriteStream& stream, basic_fifobuf<Allocator>& sb,
                       error_code& ec);
        template<class SyncWriteStream, class Allocator,
          class CompletionCondition>
            size_t write(SyncWriteStream& stream,
                         basic_fifobuf<Allocator>& sb,
                         CompletionCondition completion_condition);
        template<class SyncWriteStream, class Allocator,
          class CompletionCondition>
            size_t write(SyncWriteStream& stream,
                         basic_fifobuf<Allocator>& sb,
                         CompletionCondition completion_condition,
                         error_code& ec);

        // asynchronous write operations:
        template<class AsyncWriteStream, class ConstBufferSequence,
          class WriteHandler>
            size_t async_write(AsyncWriteStream& stream,
                               const ConstBufferSequence& buffers,
                               WriteHandler handler);
        template<class AsyncWriteStream, class ConstBufferSequence,
          class CompletionCondition, class WriteHandler>
            size_t async_write(AsyncWriteStream& stream,
                               const ConstBufferSequence& buffers,
                               CompletionCondition completion_condition,
                               WriteHandler handler);
        template<class AsyncWriteStream, class Allocator, class WriteHandler>
          size_t async_write(AsyncWriteStream& stream,
                             basic_fifobuf<Allocator>& sb,
                             WriteHandler handler);
        template<class AsyncWriteStream, class Allocator,
          class CompletionCondition, class WriteHandler>
            size_t async_write(AsyncWriteStream& stream,
                               basic_fifobuf<Allocator>& sb,
                               CompletionCondition completion_condition,
                               WriteHandler handler);

        // synchronous delimited read operations:
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            char delim);
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            char delim, error_code& ec);
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            const string& delim);
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            const string& delim, error_code& ec);
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            const regex& expr);
        template <class SyncReadStream, class Allocator>
          size_t read_until(SyncReadStream& s, basic_fifobuf<Allocator>& sb,
                            const regex& expr, error_code& ec);

        // asynchronous delimited read operations:
        template <class AsyncReadStream, class Allocator, class ReadHandler>
          void async_read_until(AsyncReadStream& s,
                                basic_fifobuf<Allocator>& sb, char delim,
                                ReadHandler handler);
        template <class AsyncReadStream, class Allocator, class ReadHandler>
          void async_read_until(AsyncReadStream& s,
                                basic_fifobuf<Allocator>& sb,
                                const string& delim, ReadHandler handler);
        template <class AsyncReadStream, class Allocator, class ReadHandler>
          void async_read_until(AsyncReadStream& s,
                                basic_fifobuf<Allocator>& sb,
                                const regex& expr, ReadHandler handler);

      } // namespace sys
    } // namespace tr2
  } // namespace std

The `CompletionCondition` parameter is used whenever an algorithm expects a
function object that when applied to an `error_code` and number of bytes as a
`size_t` returns a value testable as `true`, where a `true` return value
indicates that the algorithm should complete. In other words, if an algorithm
takes `CompletionCondition completion_condition` as its argument, it should
work correctly in the construct `if (completion_condition(ec, bc)){...}`, where
`ec` is an lvalue of type `const error_code` and `bc` is an lvalue of type
`const size_t`.

[endsect]
