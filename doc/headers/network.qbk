[section Header [^<network>] synopsis]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        ``// [link globals.getaddrinfo_errors getaddrinfo errors]:``
        extern const error_code host_not_found;
        extern const error_code host_not_found_try_again;
        extern const error_code service_not_found;

        ``// [link globals.misc_errors miscellaneous errors]:``
        extern const error_code already_open;
        extern const error_code eof;
        extern const error_code not_found;

        // Sockets:

        class ``[link classes.socket_base socket_base]``;

        template<class Protocol, class SocketService>
          class ``[link classes.basic_socket basic_socket]``;

        template<class Protocol> class ``[link classes.datagram_socket_service datagram_socket_service]``;

        template<class Protocol,
          class DatagramSocketService = datagram_socket_service<Protocol> >
            class ``[link classes.basic_datagram_socket basic_datagram_socket]``;

        template<class Protocol> class ``[link classes.stream_socket_service stream_socket_service]``;

        template<class Protocol,
          class StreamSocketService = stream_socket_service<Protocol> >
            class ``[link classes.basic_stream_socket basic_stream_socket]``;

        template<class Protocol> class ``[link classes.socket_acceptor_service socket_acceptor_service]``;

        template<class Protocol,
          class SocketAcceptorService = socket_acceptor_service<Protocol> >
            class ``[link classes.basic_socket_acceptor basic_socket_acceptor]``;

        // Socket streams:

        template<class Protocol,
          class StreamSocketService = stream_socket_service<Protocol> >
            class ``[link classes.basic_socket_streambuf basic_socket_streambuf]``;

        template<class Protocol,
          class StreamSocketService = stream_socket_service<Protocol> >
            class ``[link classes.basic_socket_iostream basic_socket_iostream]``;

        // Internet protocol:

        namespace ip {

          class ``[link classes.ip__address address]``;

          // address comparisons:
          bool operator==(const address&, const address&);
          bool operator!=(const address&, const address&);
          bool operator< (const address&, const address&);
          bool operator> (const address&, const address&);
          bool operator<=(const address&, const address&);
          bool operator>=(const address&, const address&);

          // address I/O:
          template<class CharT, class Traits>
            basic_ostream<CharT, Traits>& operator<<(
              basic_ostream<CharT, Traits>&, const address&);

          class ``[link classes.ip__address_v4 address_v4]``;

          // address_v4 comparisons:
          bool operator==(const address_v4&, const address_v4&);
          bool operator!=(const address_v4&, const address_v4&);
          bool operator< (const address_v4&, const address_v4&);
          bool operator> (const address_v4&, const address_v4&);
          bool operator<=(const address_v4&, const address_v4&);
          bool operator>=(const address_v4&, const address_v4&);

          // address_v4 I/O:
          template<class CharT, class Traits>
            basic_ostream<CharT, Traits>& operator<<(
              basic_ostream<CharT, Traits>&, const address_v4&);

          class ``[link classes.ip__address_v6 address_v6]``;

          // address_v6 comparisons:
          bool operator==(const address_v6&, const address_v6&);
          bool operator!=(const address_v6&, const address_v6&);
          bool operator< (const address_v6&, const address_v6&);
          bool operator> (const address_v6&, const address_v6&);
          bool operator<=(const address_v6&, const address_v6&);
          bool operator>=(const address_v6&, const address_v6&);

          // address_v6 I/O:
          template<class CharT, class Traits>
            basic_ostream<CharT, Traits>& operator<<(
              basic_ostream<CharT, Traits>&, const address_v6&);

          template<class InternetProtocol>
            class ``[link classes.ip__basic_endpoint basic_endpoint]``;

          // basic_endpoint comparisons:
          template<class InternetProtocol>
            bool operator==(const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);
          template<class InternetProtocol>
            bool operator!=(const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);
          template<class InternetProtocol>
            bool operator< (const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);
          template<class InternetProtocol>
            bool operator> (const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);
          template<class InternetProtocol>
            bool operator<=(const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);
          template<class InternetProtocol>
            bool operator>=(const basic_endpoint<InternetProtocol>&,
                            const basic_endpoint<InternetProtocol>&);

          // basic_endpoint I/O:
          template<class CharT, class Traits, class InternetProtocol>
            basic_ostream<CharT, Traits>& operator<<(
              basic_ostream<CharT, Traits>&,
              const basic_endpoint<InternetProtocol>&);

          class ``[link classes.ip__resolver_query_base resolver_query_base]``;

          template<class InternetProtocol>
            ``[link classes.ip__basic_resolver_query basic_resolver_query]``;

          template<class InternetProtocol>
            ``[link classes.ip__basic_resolver_entry basic_resolver_entry]``;

          template<class InternetProtocol>
            ``[link classes.ip__basic_resolver_iterator basic_resolver_iterator]``;

          template<class InternetProtocol>
            class ``[link classes.ip__resolver_service resolver_service]``;

          template<class InternetProtocol,
            class ResolverService = resolver_service<InternetProtocol> >
              class ``[link classes.ip__basic_resolver basic_resolver]``;

          string ``[link functions.ip__host_name host_name]``();
          string ``[link functions.ip__host_name host_name]``(error_code&);

          class ``[link classes.ip__tcp tcp]``;

          // tcp comparisons:
          bool operator==(const tcp& a, const tcp& b);
          bool operator!=(const tcp& a, const tcp& b);
          bool operator< (const tcp& a, const tcp& b);
          bool operator> (const tcp& a, const tcp& b);
          bool operator<=(const tcp& a, const tcp& b);
          bool operator>=(const tcp& a, const tcp& b);

          class ``[link classes.ip__udp udp]``;

          // udp comparisons:
          bool operator==(const udp& a, const udp& b);
          bool operator!=(const udp& a, const udp& b);
          bool operator< (const udp& a, const udp& b);
          bool operator> (const udp& a, const udp& b);
          bool operator<=(const udp& a, const udp& b);
          bool operator>=(const udp& a, const udp& b);

          class ``[link classes.ip__v6_only v6_only]``;

          namespace unicast {

            class ``[link classes.ip__unicast__hops hops]``;

          } // namespace unicast

          namespace multicast {

            class ``[link classes.ip__multicast__group_socket_options join_group]``;

            class ``[link classes.ip__multicast__group_socket_options leave_group]``;

            class ``[link classes.ip__multicast__outbound_interface outbound_interface]``;

            class ``[link classes.ip__multicast__hops hops]``;

            class ``[link classes.ip__multicast__enable_loopback enable_loopback]``;

          } // namespace multicast
        } // namespace ip
      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

[endsect]
