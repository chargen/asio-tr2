[library C++ TR2 Networking Library Proposal
    [quickbook 1.1]
    [copyright 2006 Christopher M. Kohlhoff]
    [purpose Networking library]
    [authors [Kohlhoff, Christopher]]
    [category template]
    [category generic]
    [last-revision $Date: 2006/06/22 13:53:09 $]
]

[/-----------------------------------------------------------------------------]

[section Overview]

To give some idea of the flavour of the proposed library, consider the
following sample code. This is part of a server program that echoes characters
it receives back to the client in upper case:

  namespace sys = std::tr2::sys;

  template <typename Iterator>
  void uppercase(Iterator begin, Iterator end)
  {
    std::locale loc("");
    for (Iterator iter = begin; iter != end; ++iter)
      *iter = std::toupper(*iter, loc);
  }

  void do_sync(
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    try
    {
      for (;;)
      {
        std::size_t count = socket.read_some(sys::buffer(buffer_space));
        uppercase(buffer_space.begin(), buffer_space.begin() + count);
        sys::write(socket, sys::buffer(buffer_space, count));
      }
    }
    catch (sys::system_error& e)
    {
    }
  }

The synchronous approach used above is straightforward to understand and easy
for programmers at any level of ability to write.

Next, the equivalent code developed using asynchronous operations:

  void do_async(
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    socket.async_read_some(sys::buffer(buffer_space),
        std::tr1::bind(handle_read, _1, _2,
          std::tr1::ref(socket), std::tr1::ref(buffer_space)));
  }

  void handle_read(
      sys::error_code ec,
      std::size_t count,
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    if (!ec)
    {
      uppercase(buffer_space.begin(), buffer_space.begin() + count);
      sys::async_write(socket, sys::buffer(buffer_space, count),
          std::tr1::bind(handle_write, _1,
            std::tr1::ref(socket), std::tr1::ref(buffer_space)));
    }
  }

  void handle_write(
      sys::error_code ec,
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    if (!ec)
    {
      socket.async_read_some(sys::buffer(buffer_space),
          std::tr1::bind(handle_read, _1, _2,
            std::tr1::ref(socket), std::tr1::ref(buffer_space)));
    }
  }

This code may appear more complex due to the inverted flow of control, but it
allows a knowledgeable programmer to write code that will scale to a great many
concurrent connections. The synchronous code requires one thread for each
connection, and on most platforms threads are a limited resource. The
asynchronous approach described in this proposal has been exercised in
production HTTP servers to thousands of concurrent connections, and similar
echo servers have been tested to tens of thousands, while using only one
thread.

[endsect]

[/-----------------------------------------------------------------------------]

[section Motivation and Scope]
[endsect]

[/-----------------------------------------------------------------------------]

[section Impact On the Standard]

This is a pure library proposal. It does not add any new language features, nor
does it alter any existing standard library headers.

This library can be implemented using compilers that conform to the C++03
standard. An implementation of this library requires operating system-specific
functions that lie outside the C++03 standard.

[section Relationship to TR1]
[endsect]

[section Relationship to Threading and Memory Model Proposals]
[endsect]

This proposal does not require, and would not be coupled to, hypothetical
standard library support for threading. The interface is intended to support
implementations on platforms where threads are not available.

However, the library interface is designed to allow the effective utilisation
of threading if available, and its behaviour with respect to threads is clearly
defined. In particular, the proposal will attempt to address:

* Thread safety of classes and functions defined in the interface.

* The threads from which an implementation is permitted to call user code, and
  when.

* The relationship between asynchronous operation initiation, completion, and
  inter-thread memory visibility.

[section Relationship to Date-Time Library Proposal]

This proposal uses classes defined in the Proposal to Add Date-Time to the C++
Standard Library (N1900).

[endsect]

[section Relationship to Filesystem Library Proposal]

The classes defined in the Diagnostics Library chapter of the Filesystem
Library Proposal (N1975) are used in this proposal. ['Note: some modification
of these classes may be required.]

[endsect]

[endsect]

[/-----------------------------------------------------------------------------]

[section Design Decisions]
[include:design design/threads.qbk]
[endsect]

[/-----------------------------------------------------------------------------]

[section Proposed Text for the Standard]
[include:headers headers/io_service.qbk]
[include:classes classes/io_service.qbk]
[include:classes classes/io_service__service.qbk]
[include:classes classes/io_service__id.qbk]
[include:classes classes/io_service__work.qbk]
[include:classes classes/io_service__strand.qbk]
[include:headers headers/timer.qbk]
[include:headers headers/buffer.qbk]
[include:classes classes/mutable_buffer.qbk]
[include:classes classes/const_buffer.qbk]
[include:classes classes/mutable_buffers_1.qbk]
[include:classes classes/const_buffers_1.qbk]
[include:headers headers/network.qbk]
[include:classes classes/socket_base.qbk]
[include:headers headers/io_algorithm.qbk]
[include:requirements requirements/mutable_buffers.qbk]
[include:requirements requirements/const_buffers.qbk]
[include:requirements requirements/sync_read_stream.qbk]
[include:requirements requirements/async_read_stream.qbk]
[include:requirements requirements/sync_write_stream.qbk]
[include:requirements requirements/async_write_stream.qbk]
[include:requirements requirements/endpoint.qbk]
[include:requirements requirements/protocol.qbk]
[include:requirements requirements/acceptor_protocol.qbk]
[endsect]

[/-----------------------------------------------------------------------------]

[section Open Issues]
[endsect]

[/-----------------------------------------------------------------------------]

[section Acknowledgements]
[endsect]

[/-----------------------------------------------------------------------------]

[section References]
[endsect]
