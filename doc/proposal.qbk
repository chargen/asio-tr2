[library C++ TR2 Networking Library Proposal
    [quickbook 1.1]
    [copyright 2006 Christopher M. Kohlhoff]
    [purpose Networking library]
    [authors [Kohlhoff, Christopher]]
    [category template]
    [category generic]
    [last-revision $Date: 2006/08/05 12:58:46 $]
]

[/-----------------------------------------------------------------------------]

[template std_note[text]
\[['Note:] [text] --['end note]\]
]

[template std_example[text code]
\[['Example:] [text]
[code]
--['end example]\]
]

[template function_block[text]
[:[text]]
]

[template function_requires[text]
[:['Requires:] [text]]
]

[template function_effects[text]
[:['Effects:] [text]]
]

[template function_returns[text]
[:['Returns:] [text]]
]

[template function_throws[text]
[:['Throws:] [text]]
]

[template function_postconditions[text]
[:['Postconditions:] [text]]
]

[template function_notes[text]
[:['Notes:] [text]]
]

[template function_note[text]
[:\[['Note:] [text] --['end note]\]]
]

[template function_example[text]
[:\[['Example:] [text]
--['end example]\]]
]

[/-----------------------------------------------------------------------------]

[def __POSIX__ /POSIX/]
[def __accept__ [@http://www.opengroup.org/onlinepubs/000095399/functions/connect.html `accept()`]]
[def __connect__ [@http://www.opengroup.org/onlinepubs/000095399/functions/connect.html `connect()`]]
[def __getpeername__ [@http://www.opengroup.org/onlinepubs/000095399/functions/getpeername.html `getpeername()`]]
[def __getsockname__ [@http://www.opengroup.org/onlinepubs/000095399/functions/getsockname.html `getsockname()`]]
[def __getsockopt__ [@http://www.opengroup.org/onlinepubs/000095399/functions/getsockopt.html `getsockopt()`]]
[def __inet_ntop__ [@http://www.opengroup.org/onlinepubs/000095399/functions/inet_ntop.html `inet_ntop()`]]
[def __inet_pton__ [@http://www.opengroup.org/onlinepubs/000095399/functions/inet_pton.html `inet_pton()`]]
[def __ioctl__ [@http://www.opengroup.org/onlinepubs/000095399/functions/ioctl.html `ioctl()`]]
[def __recvfrom__ [@http://www.opengroup.org/onlinepubs/000095399/functions/recvfrom.html `recvfrom()`]]
[def __sendto__ [@http://www.opengroup.org/onlinepubs/000095399/functions/sendto.html `sendto()`]]
[def __setsockopt__ [@http://www.opengroup.org/onlinepubs/000095399/functions/setsockopt.html `setsockopt()`]]
[def __socket__ [@http://www.opengroup.org/onlinepubs/000095399/functions/socket.html `socket()`]]
[def __sys_socket_h__ [@http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/socket.h.html `sys/socket.h`]]
[def __netinet_in_h__ [@http://www.opengroup.org/onlinepubs/000095399/basedefs/netinet/in.h.html `netinet/in.h`]]
[def __netinet_tcp_h__ [@http://www.opengroup.org/onlinepubs/000095399/basedefs/netinet/tcp.h.html `netinet/tcp.h`]]

[/-----------------------------------------------------------------------------]

[section Overview]

To give some idea of the flavour of the proposed library, consider the
following sample code. This is part of a server program that echoes characters
it receives back to the client in upper case:

  namespace sys = std::tr2::sys;

  template <typename Iterator>
  void uppercase(Iterator begin, Iterator end)
  {
    std::locale loc("");
    for (Iterator iter = begin; iter != end; ++iter)
      *iter = std::toupper(*iter, loc);
  }

  void do_sync(
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    try
    {
      for (;;)
      {
        std::size_t count = socket.read_some(sys::buffer(buffer_space));
        uppercase(buffer_space.begin(), buffer_space.begin() + count);
        sys::write(socket, sys::buffer(buffer_space, count));
      }
    }
    catch (sys::system_error& e)
    {
    }
  }

The synchronous approach used above is straightforward to understand and easy
for programmers at any level of ability to write.

Next, the equivalent code developed using asynchronous operations:

  void do_async(
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    socket.async_read_some(sys::buffer(buffer_space),
        std::tr1::bind(handle_read, _1, _2,
          std::tr1::ref(socket), std::tr1::ref(buffer_space)));
  }

  void handle_read(
      sys::error_code ec,
      std::size_t count,
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    if (!ec)
    {
      uppercase(buffer_space.begin(), buffer_space.begin() + count);
      sys::async_write(socket, sys::buffer(buffer_space, count),
          std::tr1::bind(handle_write, _1,
            std::tr1::ref(socket), std::tr1::ref(buffer_space)));
    }
  }

  void handle_write(
      sys::error_code ec,
      sys::ip::tcp::socket& socket,
      std::vector<char>& buffer_space)
  {
    if (!ec)
    {
      socket.async_read_some(sys::buffer(buffer_space),
          std::tr1::bind(handle_read, _1, _2,
            std::tr1::ref(socket), std::tr1::ref(buffer_space)));
    }
  }

This code may appear more complex due to the inverted flow of control, but it
allows a knowledgeable programmer to write code that will scale to a great many
concurrent connections. The synchronous code requires one thread for each
connection, and on most platforms threads are a limited resource. The
asynchronous approach described in this proposal has been exercised in
production HTTP servers to thousands of concurrent connections, and similar
echo servers have been tested to tens of thousands, while using only one
thread.

[endsect]

[/-----------------------------------------------------------------------------]

[section Motivation and Scope]
[endsect]

[/-----------------------------------------------------------------------------]

[section Impact On the Standard]

This is a pure library proposal. It does not add any new language features, nor
does it alter any existing standard library headers.

This library can be implemented using compilers that conform to the C++03
standard. An implementation of this library requires operating system-specific
functions that lie outside the C++03 standard.

[section Relationship to TR1]
[endsect]

[section Relationship to Threading and Memory Model Proposals]
[endsect]

This proposal does not require, and would not be coupled to, hypothetical
standard library support for threading. The interface is intended to support
implementations on platforms where threads are not available.

However, the library interface is designed to allow the effective utilisation
of threading if available, and its behaviour with respect to threads is clearly
defined. In particular, the proposal will attempt to address:

* Thread safety of classes and functions defined in the interface.

* The threads from which an implementation is permitted to call user code, and
  when.

* The relationship between asynchronous operation initiation, completion, and
  inter-thread memory visibility.

[section Relationship to Date-Time Library Proposal]

This proposal uses classes defined in the Proposal to Add Date-Time to the C++
Standard Library (N1900).

[endsect]

[section Relationship to Filesystem Library Proposal]

The classes defined in the Diagnostics Library chapter of the Filesystem
Library Proposal (N1975) are used in this proposal. ['Note: some modification
of these classes may be required.]

[endsect]

[endsect]

[/-----------------------------------------------------------------------------]

[section Design Decisions]

[include:design design/threads.qbk]

* Why the BSD sockets API
* Flaws in BSD socket API - type safety
* Should acceptor set reuse_address or not
* Buffers
* Services
* Signals
* Strands
* Two-tier concept requirements for portability
* Why read/async_read/write/async_write are needed
* Thread safety
* Why eof is an error (function contracts, 0 noop for read/write).
* Custom memory allocation
* Protocol independence
* No string constructors for IP address classes
* Timers, monotonic time
* Rationale for read_until - HTTP example
* Suppression of connection aborted error for accept operation
* Socket option requirements to allow extensibility
* ioctl provided for platform specific use, e.g. QoS settings
* Non-blocking flag is simulated
* WSAEMSGSIZE mapping on Windows to no error, set message_truncated

[endsect]

[/-----------------------------------------------------------------------------]

[section Proposed Text for the Standard]

Throughout this clause, the names of the template parameters are used to
express type requirements:

* If a template parameter is `Protocol`, the actual template argument shall
  satisfy the requirements of a [link requirements.protocol protocol].

* If a template parameter is `ResolverProtocol`, the actual template argument
  shall satisfy the requirements of a [link requirements.resolver_protocol
  resolver protocol].

* If a template parameter is `IoObjectService`, the actual template argument
  shall satisfy the requirements of an [link requirements.io_object_service I/O
  object service].

* If a template parameter is `SocketService`, the actual template argument
  shall satisfy the requirements of a [link requirements.socket_service socket
  service].

* If a template parameter is `StreamSocketService`, the actual template
  argument shall satisfy the requirements of a [link
  requirements.stream_socket_service stream socket service].

* If a template parameter is `DatagramSocketService`, the actual template
  argument shall satisfy the requirements of a [link
  requirements.datagram_socket_service datagram socket service].

* If a template parameter is `AcceptorService`, the actual template argument
  shall satisfy the requirements of an [link requirements.acceptor_service
  acceptor service].

* If a template parameter is `ResolverService`, the actual template argument
  shall satisfy the requirements of a [link requirements.resolver_service
  resolver service].

* If a template parameter is `TimerService`, the actual template argument
  shall satisfy the requirements of a [link requirements.timer_service timer
  service].

* If a template parameter is `ConvertibleToMutableBuffer`, the actual template
  argument shall satisfy the requirements for [link
  requirements.convertible_to_mutable_buffer convertibility to
  `mutable_buffer`].

* If a template parameter is `MutableBuffers`, the actual template argument
  shall satisfy the requirements of a [link requirements.mutable_buffers
  mutable buffers] object.

* If a template parameter is `ConvertibleToConstBuffer`, the actual template
  argument shall satisfy the requirements for [link
  requirements.convertible_to_const_buffer convertibility to `const_buffer`].

* If a template parameter is `ConstBuffers`, the actual template argument shall
  satisfy the requirements of a [link requirements.const_buffers constant
  buffers] object.

* If a template parameter is `GettableSocketOption`, the actual template
  argument shall satisfy the requirements of a [link
  requirements.gettable_socket_option gettable socket option].

* If a template parameter is `SettableSocketOption`, the actual template
  argument shall satisfy the requirements of a [link
  requirements.settable_socket_option settable socket option].

* If a template parameter is `IoControlCommand`, the actual template argument
  shall satisfy the requirements of an [link requirements.io_control_command
  I/O control command].

* If a template parameter is `Handler`, the actual template argument
  shall satisfy the requirements of a [link requirements.handler handler].

* If a template parameter is `CompletionHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.completion_handler
  completion handler].

* If a template parameter is `ReadHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.read_handler read
  handler].

* If a template parameter is `WriteHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.write_handler write
  handler].

* If a template parameter is `ConnectHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.connect_handler connect
  handler].

* If a template parameter is `AcceptHandler`, the actual template argument
  shall satisfy the requirements of an [link requirements.accept_handler accept
  handler].

* If a template parameter is `ResolveHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.resolve_handler resolve
  handler].

* If a template parameter is `WaitHandler`, the actual template argument
  shall satisfy the requirements of a [link requirements.wait_handler wait
  handler].

* If a template parameter is `SyncReadStream`, the actual template argument
  shall satisfy the requirements of a [link requirements.sync_read_stream
  synchronous read stream].

* If a template parameter is `AsyncReadStream`, the actual template argument
  shall satify the requirements of an [link requirements.async_read_stream
  asynchronous read stream].

* If a template parameter is `SyncWriteStream`, the actual template argument
  shall satisfy the requirements of a [link requirements.sync_write_stream
  synchronous write stream].

* If a template parameter is `AsyncWriteStream`, the actual template argument
  shall satisfy the requirements of an [link requirements.async_write_stream
  asynchronous write stream].

[include:requirements requirements/endpoint.qbk]
[include:requirements requirements/protocol.qbk]
[include:requirements requirements/resolver_protocol.qbk]
[include:requirements requirements/io_object_service.qbk]
[include:requirements requirements/socket_service.qbk]
[include:requirements requirements/stream_socket_service.qbk]
[include:requirements requirements/datagram_socket_service.qbk]
[include:requirements requirements/acceptor_service.qbk]
[include:requirements requirements/resolver_service.qbk]
[include:requirements requirements/timer_service.qbk]
[include:requirements requirements/convertible_to_mutable_buffer.qbk]
[include:requirements requirements/mutable_buffers.qbk]
[include:requirements requirements/convertible_to_const_buffer.qbk]
[include:requirements requirements/const_buffers.qbk]
[include:requirements requirements/gettable_socket_option.qbk]
[include:requirements requirements/settable_socket_option.qbk]
[include:requirements requirements/io_control_command.qbk]
[include:requirements requirements/handler.qbk]
[include:requirements requirements/sync_read_stream.qbk]
[include:requirements requirements/async_read_stream.qbk]
[include:requirements requirements/sync_write_stream.qbk]
[include:requirements requirements/async_write_stream.qbk]

[include:headers headers/io_service.qbk]
[include:classes classes/io_service.qbk]
[include:classes classes/io_service__service.qbk]
[include:classes classes/io_service__id.qbk]
[include:classes classes/io_service__work.qbk]
[include:classes classes/io_service__strand.qbk]
[include:classes classes/basic_io_object.qbk]
[include:headers headers/system_error.qbk]
[include:headers headers/timer.qbk]
[include:classes classes/basic_deadline_timer.qbk]
[include:headers headers/buffer.qbk]
[include:classes classes/mutable_buffer.qbk]
[include:classes classes/const_buffer.qbk]
[include:classes classes/mutable_buffers_1.qbk]
[include:classes classes/const_buffers_1.qbk]
[include:headers headers/network.qbk]
[include:classes classes/socket_base.qbk]
[include:classes classes/socket_base__broadcast.qbk]
[include:classes classes/socket_base__debug.qbk]
[include:classes classes/socket_base__do_not_route.qbk]
[include:classes classes/socket_base__keep_alive.qbk]
[include:classes classes/socket_base__linger.qbk]
[include:classes classes/socket_base__out_of_band_inline.qbk]
[include:classes classes/socket_base__receive_buffer_size.qbk]
[include:classes classes/socket_base__receive_low_watermark.qbk]
[include:classes classes/socket_base__reuse_address.qbk]
[include:classes classes/socket_base__send_buffer_size.qbk]
[include:classes classes/socket_base__send_low_watermark.qbk]
[include:classes classes/basic_socket.qbk]
[include:classes classes/basic_socket_acceptor.qbk]
[include:classes classes/basic_datagram_socket.qbk]
[include:classes classes/basic_stream_socket.qbk]
[include:classes classes/basic_resolver.qbk]
[include:classes classes/ip__address.qbk]
[include:classes classes/ip__address_v4.qbk]
[include:classes classes/ip__address_v6.qbk]
[include:classes classes/ip__basic_endpoint.qbk]
[include:classes classes/ip__resolver_query_base.qbk]
[include:classes classes/ip__basic_resolver_entry.qbk]
[include:classes classes/ip__basic_resolver_iterator.qbk]
[include:classes classes/ip__basic_resolver_query.qbk]
[include:classes classes/ip__tcp.qbk]
[include:classes classes/ip__tcp__no_delay.qbk]
[include:classes classes/ip__udp.qbk]
[include:classes classes/ip__v6_only.qbk]
[include:classes classes/ip__unicast__hops.qbk]
[include:classes classes/ip__multicast__join_group.qbk]
[include:classes classes/ip__multicast__leave_group.qbk]
[include:classes classes/ip__multicast__hops.qbk]
[include:classes classes/ip__multicast__enable_loopback.qbk]
[include:headers headers/io_algorithm.qbk]
[endsect]

[/-----------------------------------------------------------------------------]

[section Open Issues]

* Impact of trapping signed char implementations on streambuf and iostream support.

[endsect]

[/-----------------------------------------------------------------------------]

[section Acknowledgements]
[endsect]

[/-----------------------------------------------------------------------------]

[section References]
[endsect]
