[section:post Function [^post]]
[xrefid async.post]

  template<class CompletionToken>
    __ifr__ post(CompletionToken&& token);

[function_block Let the type `CompletionHandler` be the completion handler type
determined by performing `completion_handler_type_t<CompletionToken, void()>`.]

[function_requires The type `CompletionHandler` must satisfy the
`MoveConstructible` requirements (C++ Std, \[moveconstructible\]) and be
callable with zero arguments.]

[function_effects\n
[mdash] Constructs a function object `completion_handler` of type
`CompletionHandler`, initialized as
`completion_handler(forward<CompletionToken>(token))`.\n
[mdash] Constructs an object `result` of type
`async_result<CompletionHandler>`, initializing the object as
`result(completion_handler)`.\n
[mdash] Obtains the completion handler's associated executor object `ex` by
performing `get_associated_executor(completion_handler)`.\n
[mdash] Obtains the completion handler's associated allocator object `alloc` by
performing `get_associated_allocator(completion_handler)`.\n
[mdash] Performs `ex.post(std::move(completion_handler), alloc)`.]

[function_returns `result.get()`.]

  template<class Executor, class CompletionToken>
    __ifr__ post(const Executor& ex, CompletionToken&& token);

[function_block Let the type `CompletionHandler` be the completion handler type
determined by performing `completion_handler_type_t<CompletionToken, void()>`.]

[function_requires The type `CompletionHandler` must satisfy the
`MoveConstructible` requirements (C++ Std, \[moveconstructible\]) and be
callable with zero arguments.]

[function_effects\n
[mdash] Constructs a function object `completion_handler` of type
`CompletionHandler`, initialized as
`completion_handler(forward<CompletionToken>(token))`.\n
[mdash] Constructs an object `result` of type
`async_result<CompletionHandler>`, initializing the object as
`result(completion_handler)`.\n
[mdash] Obtains the completion handler's associated executor object `ex1` by
performing `get_associated_executor(completion_handler)`.\n
[mdash] Creates a work object `w` by performing `make_work(ex1)`.\n
[mdash] Obtains the completion handler's associated allocator object `alloc` by
performing `get_associated_allocator(completion_handler)`.\n
[mdash] Constructs a function object `f` with a function call operator that
performs `ex1.dispatch(std::move(completion_handler), alloc)` followed by
`w.reset()`.\n
[mdash] Performs `ex.post(std::move(f), alloc)`.]

[function_returns `result.get()`.]

[function_remarks This function shall not participate in overload resolution
unless `is_executor<Executor>::value` is `true`.]

  template<class ExecutionContext, class CompletionToken>
    __ifr__ post(ExecutionContext& ctx, CompletionToken&& token);

[function_returns `std::experimental::post(ctx.get_executor(),
forward<CompletionToken>(token))`.]

[function_remarks This function shall not participate in overload resolution
unless `is_convertible<ExecutionContext&, execution_context&>::value` is `true`.]

[endsect]
