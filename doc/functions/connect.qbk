[section:connect Synchronous connect operations]
[xrefid socket.algo.connect]

  template<class Protocol, class EndpointSequence>
    typename Protocol::endpoint connect(basic_socket<Protocol>& s,
                                        const EndpointSequence& endpoints);
  template<class Protocol, class InputIterator>
    typename Protocol::endpoint connect(basic_socket<Protocol>& s,
                                        const EndpointSequence& endpoints,
                                        error_code& ec);

[function_returns `connect(s, endpoints, __empty_capture__(auto, auto){ return
true; }, ec)`.]

  template<class Protocol, class EndpointSequence, class ConnectCondition>
    typename Protocol::endpoint connect(basic_socket<Protocol>& s,
                                        const EndpointSequence& endpoints,
                                        ConnectCondition c);
  template<class Protocol, class InputIterator, class ConnectCondition>
    typename Protocol::endpoint connect(basic_socket<Protocol>& s,
                                        const EndpointSequence& endpoints,
                                        ConnectCondition c, error_code& ec);

[function_effects If `s.is_open()` is `true`, performs `s.close(ec)`. Performs
`ec.clear()`. Returns the first element `ep` in the sequence `endpoints` for
which `c(ec, ep)` yields `true` and, if so, for which the synchronous operation
`s.connect(ep, ec)` succeeds. If no such element is found, `ec` contains the
error code produced by the last unsuccessful connect operation and the function
returns `typename Protocol::endpoint()`.]

[function_error_conditions\n
[mdash] `socket_errc::not_found` [mdash] if `endpoints.empty()` or if the
function object `c` returned `false` for all elements in the sequence.]

  template<class Protocol, class InputIterator>
    InputIterator connect(basic_socket<Protocol>& s,
                          InputIterator first, InputIterator last);
  template<class Protocol, class InputIterator>
    InputIterator connect(basic_socket<Protocol>& s,
                          InputIterator first, InputIterator last,
                          error_code& ec);

[function_returns `connect(s, first, last, __empty_capture__(auto, auto){
return true; }, ec)`.]

  template<class Protocol, class InputIterator, class ConnectCondition>
    InputIterator connect(basic_socket<Protocol>& s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c);
  template<class Protocol, class InputIterator, class ConnectCondition>
    InputIterator connect(basic_socket<Protocol>& s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c, error_code& ec);

[function_requires `ConnectCondition` is a function object type meeting
CopyConstructible requirements (C++ Std \[copyconstructible\]).]

[function_effects If `s.is_open()` is `true`, performs `s.close(ec)`. Performs
`ec.clear()`. Returns the first iterator `i` in the range [half_open_range
`first`,`last`] for which `c(ec, *i)` yields `true` and, if so, for which the
synchronous operation `s.connect(*i, ec)` succeeds. If no such iterator is
found, `ec` contains the error code produced by the last unsuccessful connect
operation and the function returns `last`.]

[function_error_conditions\n
[mdash] `socket_errc::not_found` [mdash] if `first == last` or if the function
object `c` returned `false` for all iterators in the range.]

[endsect]
