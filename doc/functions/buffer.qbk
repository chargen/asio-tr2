[section:buffer Buffer creation functions]
[xrefid buffer.creation]

In the functions below, `T` must be a trivially copyable type.

For the function overloads below that accept an argument of type `vector<>`,
the buffer objects returned are invalidated by any vector operation that also
invalidates all references, pointers and iterators referring to the elements in
the sequence (C++ Std, [vector]).

For the function overloads below that accept an argument of type
`basic_string<>`, the buffer objects returned are invalidated according to the
rules defined for invalidation of references, pointers and iterators referring
to elements of the sequence (C++ Std, [string.require]).

  mutable_buffers_1 buffer(void* p, size_t n) noexcept;

[function_returns `mutable_buffers_1(p, n)`.]

  const_buffers_1 buffer(const void* p, size_t n) noexcept;

[function_returns `const_buffers_1(p, n)`.]

  mutable_buffers_1 buffer(const mutable_buffer& b) noexcept;

[function_returns `mutable_buffers_1(b)`.]

  mutable_buffers_1 buffer(const mutable_buffer& b, size_t n) noexcept;

[function_returns A `mutable_buffers_1` value equivalent to:
``
  mutable_buffers_1(b.data(), min(b.size(), n));
``]

  const_buffers_1 buffer(const const_buffer& b) noexcept;

[function_returns `const_buffers_1(b)`.]

  const_buffers_1 buffer(const const_buffer& b, size_t n) noexcept;

[function_returns A `const_buffers_1` value equivalent to:
``
  const_buffers_1(b.data(), min(b.size(), n));
``]

  template<class T, size_t N>
    mutable_buffers_1 buffer(T (&data)[N]) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(const T (&data)[N]) noexcept;
  template<class T, size_t N>
    mutable_buffers_1 buffer(array<T, N>& data) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(array<const T, N>& data) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(const array<T, N>& data) noexcept;
  template<class T, class Allocator>
    mutable_buffers_1 buffer(vector<T, Allocator>& data) noexcept;
  template<class T, class Allocator>
    const_buffers_1 buffer(const vector<T, Allocator>& data) noexcept;
  template<class CharT, class Traits, class Allocator>
    mutable_buffers_1 buffer(basic_string<CharT, Traits, Allocator>& data) noexcept;
  template<class CharT, class Traits>
    const_buffers_1 buffer(basic_string_view<CharT, Traits> data) noexcept;

[function_returns
``
  buffer(
    begin(data) != end(data) ? std::addressof(*begin(data)) : nullptr,
    (end(data) - begin(data)) * sizeof(*begin(data)));
``]

  template<class T, size_t N>
    mutable_buffers_1 buffer(T (&data)[N], size_t n) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(const T (&data)[N], size_t n) noexcept;
  template<class T, size_t N>
    mutable_buffers_1 buffer(array<T, N>& data, size_t n) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(array<const T, N>& data, size_t n) noexcept;
  template<class T, size_t N>
    const_buffers_1 buffer(const array<T, N>& data, size_t n) noexcept;
  template<class T, class Allocator>
    mutable_buffers_1 buffer(vector<T, Allocator>& data, size_t n) noexcept;
  template<class T, class Allocator>
    const_buffers_1 buffer(const vector<T, Allocator>& data, size_t n) noexcept;
  template<class CharT, class Traits, class Allocator>
    mutable_buffers_1 buffer(basic_string<CharT, Traits, Allocator>& data,
                             size_t n) noexcept;
  template<class CharT, class Traits>
    const_buffers_1 buffer(basic_string_view<CharT, Traits> data,
                           size_t n) noexcept;

[function_returns `buffer(buffer(data), n)`.]

[endsect]
