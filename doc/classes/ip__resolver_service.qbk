[section:ip__resolver_service Class template [^ip::resolver_service]]

Instances of the `resolver_service` class template meet the requirements
of a [link requirements.resolver_service `ResolverService`].

  namespace std {
    namespace tr2 {
      namespace sys {
        namespace ip {

          template<class InternetProtocol>
          class resolver_service :
            public io_service::service
          {
          public:
            static io_service::id id;

            // types:
            typedef InternetProtocol protocol_type;
            typedef typename InternetProtocol::endpoint endpoint_type;
            typedef basic_resolver_query<InternetProtocol> query_type;
            typedef basic_resolver_iterator<InternetProtocol> iterator_type;
            typedef ``['unspecified]`` implementation_type;

            // constructors:
            explicit resolver_service(io_service& ios);

            // members:
            void construct(implementation_type& impl);

            void destroy(implementation_type& impl);

            error_code cancel(implementation_type& impl, error_code& ec);

            iterator_type resolve(implementation_type& impl,
                                  const query_type& q, error_code& ec);

            template<class ResolveHandler>
              void async_resolve(implementation_type& impl,
                                 const query_type& q, ResolveHandler handler);

            iterator_type resolve(implementation_type& impl,
                                  const endpoint_type& e, error_code& ec);

            template<class ResolveHandler>
              void async_resolve(implementation_type& impl,
                                 const endpoint_type& e,
                                 ResolveHandler handler);

          private:
            virtual void shutdown_service();
          };

        } // namespace ip
      } // namespace sys
    } // namespace tr2
  } // namespace std

[section [^ip::resolver_service] constructors]

  explicit resolver_service(io_service& ios);

[function_effects Constructs an object of class
`resolver_service<InternetProtocol>`, initialising the base class with
`io_service::service(ios)`.]

[endsect]

[section [^ip::resolver_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the resolver implementation `impl`.]

  void destroy(implementation_type& impl);

[function_effects Cleans up resources owned by the resolver implementation
`impl`. Cancels asynchronous operations associated with `impl` as if by
performing:
``
  error_code ec;
  cancel(impl, ec);
``]

  error_code cancel(implementation_type& impl, error_code& ec);

[function_effects Causes any outstanding asynchronous operations to complete as
soon as possible. Handlers for cancelled operations shall be passed the error
code `error::operation_canceled`.]

[function_returns `ec`.]

  iterator_type resolve(implementation_type& impl,
                        const query_type& q, error_code& ec);

[function_effects Translates a query into a sequence of
`basic_resolver_entry<InternetProtocol>` objects, as if by __POSIX__
__getaddrinfo__.]

[function_returns On success, an iterator object `i` such that the condition `i
!= iterator_type()` holds. Otherwise `iterator_type()`.]

  template<class ResolveHandler>
    void async_resolve(implementation_type& impl,
                       const query_type& q, ResolveHandler handler);

[function_effects Initiates an asynchronous operation to translate a query into
a sequence of `basic_resolver_entry<InternetProtocol>` objects, as if by
__POSIX__ __getaddrinfo__. The operation is performed via the `io_service`
object returned by `get_io_service()` and behaves according to [link
requirements.asynchronous_operations asynchronous operation] requirements.]

[function_block If the operation completes successfully, the `ResolveHandler`
object `handler` is invoked with an iterator object `i` such that the condition
`i != iterator_type()` holds. Otherwise it is invoked with `iterator_type()`.]

  iterator_type resolve(implementation_type& impl,
                        const endpoint_type& e, error_code& ec);

[function_effects Translates an endpoint into a sequence of zero or one
`basic_resolver_entry<InternetProtocol>` objects, as if by __POSIX__
__getnameinfo__.]

[function_returns On success, an iterator object `i` such that the condition `i
!= iterator_type()` holds. Otherwise `iterator_type()`.]

  template<class ResolveHandler>
    void async_resolve(implementation_type& impl,
                       const endpoint_type& e,
                       ResolveHandler handler);

[function_effects Initiates an asynchronous operation to translate an endpoint
into a sequence of zero or one `basic_resolver_entry<InternetProtocol>`
objects, as if by __POSIX__ __getnameinfo__. The operation is performed via the
`io_service` object returned by `get_io_service()` and behaves according to
[link requirements.asynchronous_operations asynchronous operation]
requirements.]

[function_block If the operation completes successfully, the `ResolveHandler`
object `handler` is invoked with an iterator object `i` such that the condition
`i != iterator_type()` holds. Otherwise it is invoked with `iterator_type()`.]

[endsect]

[endsect]
