[section:basic_socket Class template [^basic_socket]]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template<class Protocol, class SocketService>
        class basic_socket :
          public basic_io_object<SocketService>,
          public socket_base
        {
        public:
          // types:
          typedef typename SocketService::native_handle_type native_handle_type;
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;

          // members:
          native_handle_type native_handle();

          void open(const protocol_type& protocol = protocol_type());
          void open(const protocol_type& protocol, error_code& ec);

          void assign(const protocol_type& protocol,
                      const native_handle_type& native_socket);
          void assign(const protocol_type& protocol,
                      const native_handle_type& native_socket, error_code& ec);

          bool is_open() const;

          void close();
          void close(error_code& ec);

          void cancel();
          void cancel(error_code& ec);

          template<class SettableSocketOption>
            void set_option(const SettableSocketOption& option);
          template<class SettableSocketOption>
            void set_option(const SettableSocketOption& option, error_code& ec);

          template<class GettableSocketOption>
            void get_option(GettableSocketOption& option) const;
          template<class GettableSocketOption>
            void get_option(GettableSocketOption& option, error_code& ec) const;

          template<class IoControlCommand>
            void io_control(IoControlCommand& command);
          template<class IoControlCommand>
            void io_control(IoControlCommand& command, error_code& ec);

          bool at_mark() const;
          bool at_mark(error_code& ec) const;

          size_t available() const;
          size_t available(error_code& ec) const;

          void bind(const endpoint_type& endpoint);
          void bind(const endpoint_type& endpoint, error_code& ec);

          void shutdown(shutdown_type what);
          void shutdown(shutdown_type what, error_code& ec);

          endpoint_type local_endpoint() const;
          endpoint_type local_endpoint(error_code& ec) const;

          endpoint_type remote_endpoint() const;
          endpoint_type remote_endpoint(error_code& ec) const;

          void connect(const endpoint_type& endpoint);
          void connect(const endpoint_type& endpoint, error_code& ec);

          template<class ConnectHandler>
            void async_connect(const endpoint_type& endpoint,
                               ConnectHandler handler);

        protected:
          // constructors:
          explicit basic_socket(io_service& ios);
          basic_socket(io_service& ios, const protocol_type& protocol);
          basic_socket(io_service& ios, const endpoint_type& endpoint);
          basic_socket(io_service& ios, const protocol_type& protocol,
                       const native_handle_type& native_socket);
          ~basic_socket();
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

[section [^basic_socket] constructors]

  explicit basic_socket(io_service& ios);

[function_effects Constructs an object of class `basic_socket<Protocol,
SocketService>`, initialising the base class with `basic_io_object(ios)`.]

  basic_socket(io_service& ios, const protocol_type& protocol);

[function_effects Constructs an object of class `basic_socket<Protocol,
SocketService>`, initialising the base class with `basic_io_object(ios)`, then
opening the socket as if by calling:
``
  error_code ec;
  this->service.open(this->implementation, protocol, ec);
  if (ec) throw system_error(ec);
``]

  basic_socket(io_service& ios, const endpoint_type& endpoint);

[function_effects Constructs an object of class `basic_socket<Protocol,
SocketService>`, initialising the base class with `basic_io_object(ios)`, then
opening and binding the socket and marking it as listening as if by calling:
``
  error_code ec;
  this->service.open(this->implementation, endpoint.protocol(), ec);
  if (ec) throw system_error(ec);
  this->service.bind(this->implementation, endpoint, ec);
  if (ec) throw system_error(ec);
``]

  basic_socket(io_service& ios, const protocol_type& protocol,
               const native_handle_type& native_socket);

[function_effects Constructs an object of class `basic_socket<Protocol,
SocketService>`, initialising the base class with `basic_io_object(ios)`, then
assigning the existing native socket into the object as if by calling:
``
  error_code ec;
  this->service.assign(this->implementation, protocol, native_socket, ec);
  if (ec) throw system_error(ec);
``]

[endsect]

[section [^basic_socket] members]

  native_handle_type native_handle();

[function_returns `this->service.native_handle(this->implementation)`.]

  void open(const protocol_type& protocol);
  void open(const protocol_type& protocol, error_code& ec);

[function_effects Calls `this->service.open(this->implementation, protocol,
ec)`.]

  void assign(const protocol_type& protocol,
              const native_handle_type& native_socket);
  void assign(const protocol_type& protocol,
              const native_handle_type& native_socket, error_code& ec);

[function_effects Calls `this->service.assign(this->implementation, protocol,
native_socket, ec)`.]

  bool is_open() const;

[function_returns `this->service.is_open(this->implementation)`.]

  void close();
  void close(error_code& ec);

[function_effects Calls `this->service.close(this->implementation, ec)`.]

  void cancel();
  void cancel(error_code& ec);

[function_effects Calls `this->service.cancel(this->implementation, ec)`.]

  template<class SettableSocketOption>
    void set_option(const SettableSocketOption& option);
  template<class SettableSocketOption>
    void set_option(const SettableSocketOption& option, error_code& ec);

[function_effects Calls `this->service.set_option(this->implementation, option,
ec)`.]

  template<class GettableSocketOption>
    void get_option(GettableSocketOption& option);
  template<class GettableSocketOption>
    void get_option(GettableSocketOption& option, error_code& ec);

[function_effects Calls `this->service.get_option(this->implementation, option,
ec)`.]

  template<class IoControlCommand>
    void io_control(IoControlCommand& command);
  template<class IoControlCommand>
    void io_control(IoControlCommand& command, error_code& ec);

[function_effects Calls `this->service.io_control(this->implementation,
command, ec)`.]

  bool at_mark() const;
  bool at_mark(error_code& ec) const;

[function_returns `this->service.at_mark(this->implementation, ec)`.]

  size_t available() const;
  size_t available(error_code& ec) const;

[function_returns `this->service.available(this->implementation, ec)`.]

  void bind(const endpoint_type& endpoint);
  void bind(const endpoint_type& endpoint, error_code& ec);

[function_effects Calls `this->service.bind(this->implementation, endpoint,
ec)`.]

  void listen(int backlog = max_connections);
  void listen(int backlog, error_code& ec);

[function_effects Calls `this->service.listen(this->implementation, backlog,
ec)`.]

  void shutdown(shutdown_type what);
  void shutdown(shutdown_type what, error_code& ec);

[function_effects Calls `this->service.shutdown(this->implementation, what,
ec)`.]

  endpoint_type local_endpoint() const;
  endpoint_type local_endpoint(error_code& ec) const;

[function_returns `this->service.local_endpoint(this->implementation, ec)`.]

  endpoint_type remote_endpoint() const;
  endpoint_type remote_endpoint(error_code& ec) const;

[function_returns `this->service.remote_endpoint(this->implementation, ec)`.]

  void connect(const endpoint_type& endpoint);
  void connect(const endpoint_type& endpoint, error_code& ec);

[function_effects If `is_open()` is false, opens the socket by calling:
``
  this->service.open(this->implementation, endpoint.protocol(), ec);
``
then, if no error has occurred, connects the socket by calling:
``
  this->service.connect(this->implementation, endpoint, ec);
``]

  template<class ConnectHandler>
    void async_connect(const endpoint_type& endpoint, ConnectHandler handler);

[function_effects If `is_open()` is false, opens the socket by calling:
``
  error_code ec;
  this->service.open(this->implementation, endpoint.protocol(), ec);
``
If the socket failed to open, uses
`this->service.get_io_service().post(__dotdotdot__)` to invoke the handler with
the `error_code` value `ec`. Otherwise initiates an asynchronous operation to
connect the socket by calling:
``
  this->service.async_connect(this->implementation, endpoint, handler);
``]

[endsect]

[endsect]
