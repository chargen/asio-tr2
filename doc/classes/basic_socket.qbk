[section:basic_socket Class template [^basic_socket]]

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Protocol, class SocketTraits, class SocketService>
        class basic_socket :
          public basic_io_object<SocketService>,
          public socket_base
        {
        public:
          // types:
          typedef typename SocketService::native_type native_type;
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef SocketTraits traits_type;

          // constructors:
          explicit basic_socket(std::tr2::sys::io_service& io_service);
          basic_socket(std::tr2::sys::io_service& io_service,
                       const protocol_type& protocol);
          basic_socket(std::tr2::sys::io_service& io_service,
                       const endpoint_type& endpoint);
          basic_socket(std::tr2::sys::io_service& io_service,
                       const protocol_type& protocol,
                       const native_type& native_socket);

          // members:
          native_type native();

          void open(const protocol_type& protocol = protocol_type());
          error_code open(const protocol_type& protocol, error_code& ec);

          void assign(const protocol_type& protocol,
                      const native_type& native_socket);
          error_code assign(const protocol_type& protocol,
                            const native_type& native_socket, error_code& ec);

          bool is_open() const;

          void close();
          error_code close(error_code& ec);

          void cancel();
          error_code cancel(error_code& ec);

          template<class SettableSocketOption>
            void set_option(const SettableSocketOption& option);
          template<class SettableSocketOption>
            error_code set_option(const SettableSocketOption& option,
                                  error_code& ec);

          template<class GettableSocketOption>
            void get_option(GettableSocketOption& option) const;
          template<class GettableSocketOption>
            error_code get_option(GettableSocketOption& option,
                                  error_code& ec) const;

          template<class IoControlCommand>
            void io_control(IoControlCommand& command);
          template<class IoControlCommand>
            error_code io_control(IoControlCommand& command, error_code& ec);

          bool at_mark() const;
          bool at_mark(error_code& ec) const;

          size_t available() const;
          size_t available(error_code& ec) const;

          void bind(const endpoint_type& endpoint);
          error_code bind(const endpoint_type& endpoint, error_code& ec);

          void listen(int backlog = -1);
          error_code listen(int backlog, error_code& ec);

          template<class SocketTraits1, class SocketService1>
            void accept(
              basic_socket<Protocol,SocketTraits1,SocketService1>& socket);
          template<class SocketTraits1, class SocketService1>
            error_code accept(
              basic_socket<Protocol,SocketTraits1,SocketService1>& socket,
              error_code& ec);

          template<class SocketTraits1, class SocketService1,
            class AcceptHandler>
              void async_accept(
                basic_socket<Protocol,SocketTraits1,SocketService1>& socket,
                AcceptHandler handler);

          template<class SocketTraits1, class SocketService1>
            void accept(
              basic_socket<Protocol,SocketTraits1,SocketService1>& socket,
              endpoint_type& endpoint);
          template<class SocketTraits1, class SocketService1>
            error_code accept(
              basic_socket<Protocol,SocketTraits1,SocketService1>& socket,
              endpoint_type& endpoint, error_code& ec);

          template<class SocketTraits1, class SocketService1,
            class AcceptHandler>
              void async_accept(
                basic_socket<Protocol,SocketTraits1,SocketService1>& socket,
                endpoint_type& endpoint, AcceptHandler handler);

          void connect(const endpoint_type& endpoint);
          error_code connect(const endpoint_type& endpoint, error_code& ec);

          template<class ConnectHandler>
            void async_connect(const endpoint_type& endpoint,
                               ConnectHandler handler);

          endpoint_type local_endpoint() const;
          endpoint_type local_endpoint(error_code& ec) const;

          endpoint_type remote_endpoint() const;
          endpoint_type remote_endpoint(error_code& ec) const;

          void shutdown(shutdown_type what);
          error_code shutdown(shutdown_type what, error_code& ec);

          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers);
          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers,
                           error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive(const MutableBufferSequence& buffers,
                               ReadHandler handler);

          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers,
                           socket_base::message_flags flags);
          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers,
                           socket_base::message_flags flags, error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive(const MutableBufferSequence& buffers,
                               socket_base::message_flags flags,
                               ReadHandler handler);

          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers,
                           socket_base::message_flags flags,
                           socket_base::message_flags& out_flags);
          template<class MutableBufferSequence>
            size_t receive(const MutableBufferSequence& buffers,
                           socket_base::message_flags flags,
                           socket_base::message_flags& out_flags,
                           error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive(const MutableBufferSequence& buffers,
                               socket_base::message_flags flags,
                               socket_base::message_flags& out_flags,
                               ReadHandler handler);

          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer>
              size_t receive(const MutableBufferSequence& buffers,
                             socket_base::message_flags flags,
                             socket_base::message_flags& out_flags,
                             const ConvertibleToMutableBuffer& control_data);
          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer>
              size_t receive(const MutableBufferSequence& buffers,
                             socket_base::message_flags flags,
                             socket_base::message_flags& out_flags,
                             const ConvertibleToMutableBuffer& control_data,
                             error_code& ec);

          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer, class ReadHandler>
              void async_receive(const MutableBufferSequence& buffers,
                                 socket_base::message_flags flags,
                                 socket_base::message_flags& out_flags,
                                 const ConvertibleToMutableBuffer& control_data,
                                 ReadHandler handler);

          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender);
          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender, error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive_from(const MutableBufferSequence& buffers,
                                    endpoint_type& sender,
                                    ReadHandler handler);

          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender,
                                socket_base::message_flags flags);
          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender,
                                socket_base::message_flags flags,
                                error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive_from(const MutableBufferSequence& buffers,
                                    endpoint_type& sender,
                                    socket_base::message_flags flags,
                                    ReadHandler handler);

          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender,
                                socket_base::message_flags flags,
                                socket_base::message_flags& out_flags);
          template<class MutableBufferSequence>
            size_t receive_from(const MutableBufferSequence& buffers,
                                endpoint_type& sender,
                                socket_base::message_flags flags,
                                socket_base::message_flags& out_flags,
                                error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive_from(const MutableBufferSequence& buffers,
                                    endpoint_type& sender,
                                    socket_base::message_flags flags,
                                    socket_base::message_flags& out_flags,
                                    ReadHandler handler);

          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer>
              size_t receive_from(const MutableBufferSequence& buffers,
                                  endpoint_type& sender,
                                  socket_base::message_flags flags,
                                  socket_base::message_flags& out_flags,
                                  const ConvertibleToMutableBuffer&
                                    control_data);
          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer>
              size_t receive_from(const MutableBufferSequence& buffers,
                                  endpoint_type& sender,
                                  socket_base::message_flags flags,
                                  socket_base::message_flags& out_flags,
                                  const ConvertibleToMutableBuffer&
                                    control_data,
                                  error_code& ec);

          template<class MutableBufferSequence,
            class ConvertibleToMutableBuffer, class ReadHandler>
              void async_receive_from(const MutableBufferSequence& buffers,
                                      endpoint_type& sender,
                                      socket_base::message_flags flags,
                                      socket_base::message_flags& out_flags,
                                      const ConvertibleToMutableBuffer&
                                        control_data,
                                      ReadHandler handler);

          template<class MutableBufferSequence>
            size_t read_some(const MutableBufferSequence& buffers);
          template<class MutableBufferSequence>
            size_t read_some(const MutableBufferSequence& buffers,
                             error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_read_some(const MutableBufferSequence& buffers,
                                 ReadHandler handler);

          template<class ConstBufferSequence>
            size_t send(const ConstBufferSequence& buffers);
          template<class ConstBufferSequence>
            size_t send(const ConstBufferSequence& buffers, error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_send(const ConstBufferSequence& buffers,
                            WriteHandler handler);

          template<class ConstBufferSequence>
            size_t send(const ConstBufferSequence& buffers,
                        socket_base::message_flags flags);
          template<class ConstBufferSequence>
            size_t send(const ConstBufferSequence& buffers,
                        socket_base::message_flags flags, error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_send(const ConstBufferSequence& buffers,
                            socket_base::message_flags flags,
                            WriteHandler handler);

          template<class ConstBufferSequence, class ConvertibleToConstBuffer>
            size_t send(const ConstBufferSequence& buffers,
                        socket_base::message_flags flags,
                        const ConvertibleToConstBuffer& control_data);
          template<class ConstBufferSequence, class ConvertibleToConstBuffer>
            size_t send(const ConstBufferSequence& buffers,
                        socket_base::message_flags flags,
                        const ConvertibleToConstBuffer& control_data,
                        error_code& ec);

          template<class ConstBufferSequence, class ConvertibleToConstBuffer,
            class WriteHandler>
              void async_send(const ConstBufferSequence& buffers,
                              socket_base::message_flags flags,
                              const ConvertibleToConstBuffer& control_data,
                              WriteHandler handler);

          template<class ConstBufferSequence>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination);
          template<class ConstBufferSequence>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination, error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_send_to(const ConstBufferSequence& buffers,
                               const endpoint_type& destination,
                               WriteHandler handler);

          template<class ConstBufferSequence>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination,
                           socket_base::message_flags flags);
          template<class ConstBufferSequence>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination,
                           socket_base::message_flags flags, error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_send_to(const ConstBufferSequence& buffers,
                               const endpoint_type& destination,
                               socket_base::message_flags flags,
                               WriteHandler handler);

          template<class ConstBufferSequence, class ConvertibleToConstBuffer>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination,
                           socket_base::message_flags flags,
                           const ConvertibleToConstBuffer& control_data);
          template<class ConstBufferSequence, class ConvertibleToConstBuffer>
            size_t send_to(const ConstBufferSequence& buffers,
                           const endpoint_type& destination,
                           socket_base::message_flags flags,
                           const ConvertibleToConstBuffer& control_data,
                           error_code& ec);

          template<class ConstBufferSequence, class ConvertibleToConstBuffer,
            class WriteHandler>
              void async_send_to(const ConstBufferSequence& buffers,
                                 const endpoint_type& destination,
                                 socket_base::message_flags flags,
                                 const ConvertibleToConstBuffer& control_data,
                                 WriteHandler handler);

          template<class ConstBufferSequence>
            size_t write_some(const ConstBufferSequence& buffers);
          template<class ConstBufferSequence>
            size_t write_some(const ConstBufferSequence& buffers,
                              error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_write_some(const ConstBufferSequence& buffers,
                                  WriteHandler handler);
        };

        // convenience functions:

        template<class Protocol, class SocketTraits, class SocketService>
          void connect(basic_socket<Protocol,SocketTraits,SocketService>& s,
                       const typename Procotol::endpoint& e);
        template<class Protocol, class SocketTraits, class SocketService>
          error_code connect(
            basic_socket<Protocol,SocketTraits,SocketService>& s,
            const typename Procotol::endpoint& e, error_code& ec);

        template<class Protocol, class SocketTraits, class SocketService,
          class ConnectHandler>
            void async_connect(
              basic_socket<Protocol,SocketTraits,SocketService>& s,
              const typename Procotol::endpoint& e, ConnectHandler handler);

        template<class Protocol, class SocketTraits, class SocketService,
          class Iterator>
            void connect(basic_socket<Protocol,SocketTraits,SocketService>& s,
                         Iterator first, Iterator last);
        template<class Protocol, class SocketTraits, class SocketService,
          class Iterator>
            error_code connect(
              basic_socket<Protocol,SocketTraits,SocketService>& s,
              Iterator first, Iterator last, error_code& ec);

        template<class Protocol, class SocketTraits, class SocketService,
          class Iterator, class ConnectHandler>
            void async_connect(
              basic_socket<Protocol,SocketTraits,SocketService>& s,
              Iterator first, Iterator last, ConnectHandler handler);

      } // namespace sys
    } // namespace tr2
  } // namespace std

[section [^basic_socket] constructors]

  explicit basic_socket(std::tr2::sys::io_service& io_service);

[function_effects Constructs an object of class
`basic_socket<Protocol,SocketService>`, initialising the base class with
`basic_io_object(io_service)`.]

  basic_socket(std::tr2::sys::io_service& io_service,
               const protocol_type& protocol);

[function_effects Constructs an object of class
`basic_socket<Protocol,SocketService>`, initialising the base class with
`basic_io_object(io_service)`, then opening the socket as if by calling:
``
  error_code ec;
  this->service.open(this->implementation, protocol, ec);
  if (ec) throw system_error(ec);
``]

  basic_socket(std::tr2::sys::io_service& io_service,
               const endpoint_type& endpoint);

[function_effects Constructs an object of class
`basic_socket<Protocol,SocketService>`, initialising the base class with
`basic_io_object(io_service)`, then opening and binding the socket and marking
it as listening as if by calling:
``
  error_code ec;
  this->service.open(this->implementation, endpoint.protocol(), ec);
  if (ec) throw system_error(ec);
  if (traits_type::has_bind)
  {
    this->service.bind(this->implementation, endpoint, ec);
    if (ec) throw system_error(ec);
  }
  if (traits_type::has_listen)
  {
    this->service.listen(this->implementation, -1, ec);
    if (ec) throw system_error(ec);
  }
``]

  basic_socket(std::tr2::sys::io_service& io_service,
               const protocol_type& protocol,
               const native_type& native_socket);

[function_effects Constructs an object of class
`basic_socket<Protocol,SocketService>`, initialising the base class with
`basic_io_object(io_service)`, then assigning the existing native socket into
the object as if by calling:
``
  error_code ec;
  this->service.assign(this->implementation, protocol, native_socket, ec);
  if (ec) throw system_error(ec);
``]

[endsect]

[section [^basic_socket] members]

  native_type native();

[function_returns `this->service.native(this->implementation)`.]

  void open(const protocol_type& protocol);
  error_code open(const protocol_type& protocol, error_code& ec);

[function_returns `this->service.open(this->implementation, protocol, ec)`.]

  void assign(const protocol_type& protocol,
    const native_type& native_socket);
  error_code assign(const protocol_type& protocol,
                    const native_type& native_socket, error_code& ec);

[function_returns `this->service.assign(this->implementation, protocol,
native_socket, ec)`.]

  bool is_open() const;

[function_returns `this->service.is_open(this->implementation)`.]

  void close();
  error_code close(error_code& ec);

[function_returns `this->service.close(this->implementation, ec)`.]

  void cancel();
  error_code cancel(error_code& ec);

[function_returns `this->service.cancel(this->implementation, ec)`.]

  template<class SettableSocketOption>
    void set_option(const SettableSocketOption& option);
  template<class SettableSocketOption>
    error_code set_option(const SettableSocketOption& option,
                          error_code& ec);

[function_returns `this->service.set_option(this->implementation, option, ec)`.]

  template<class GettableSocketOption>
    void get_option(GettableSocketOption& option);
  template<class GettableSocketOption>
    error_code get_option(GettableSocketOption& option, error_code& ec);

[function_returns `this->service.get_option(this->implementation, option, ec)`.]

  template<class IoControlCommand>
    void io_control(IoControlCommand& command);
  template<class IoControlCommand>
    error_code io_control(IoControlCommand& command, error_code& ec);

[function_returns `this->service.io_control(this->implementation, command,
ec)`.]

  bool at_mark() const;
  bool at_mark(error_code& ec) const;

[function_requires `traits_type::has_mark`.]

[function_returns `this->service.at_mark(this->implementation, ec)`.]

  size_t available() const;
  size_t available(error_code& ec) const;

[function_requires `traits_type::has_available`.]

[function_returns `this->service.available(this->implementation, ec)`.]

  void bind(const endpoint_type& endpoint);
  error_code bind(const endpoint_type& endpoint, error_code& ec);

[function_requires `traits_type::has_bind`.]

[function_returns `this->service.bind(this->implementation, endpoint, ec)`.]

  void listen(int backlog = -1);
  error_code listen(int backlog, error_code& ec);

[function_requires `traits_type::has_listen`.]

[function_returns `this->service.listen(this->implementation, backlog, ec)`.]

  template<class SocketTraits1, class SocketService1>
    void accept(
      basic_socket<Protocol,SocketTraits1,SocketService1>& socket);
  template<class SocketTraits1, class SocketService1>
    error_code accept(
      basic_socket<Protocol,SocketTraits1, SocketService1>& socket,
      error_code& ec);

[function_requires `traits_type::has_accept`.]

[function_returns `this->service.accept(this->implementation, socket, 0, ec)`.]

  template<class SocketTraits1, class SocketService1,
    class AcceptHandler>
      void async_accept(
        basic_socket<Protocol, SocketTraits1, SocketService1>& socket,
        AcceptHandler handler);

[function_requires `traits_type::has_accept`.]

[function_effects Calls `this->service.async_accept(this->implementation,
socket, 0, handler)`.]

  template<class SocketTraits1, class SocketService1>
    void accept(
      basic_socket<Protocol, SocketTraits1, SocketService1>& socket,
      endpoint_type& endpoint);
  template<class SocketTraits1, class SocketService1>
    error_code accept(
      basic_socket<Protocol, SocketTraits1, SocketService1>& socket,
      endpoint_type& endpoint, error_code& ec);

[function_requires `traits_type::has_accept`.]

[function_returns `this->service.accept(this->implementation, socket,
&endpoint, ec)`.]

  template<class SocketTraits1, class SocketService1,
    class AcceptHandler>
      void async_accept(
        basic_socket<Protocol, SocketTraits1, SocketService1>& socket,
        endpoint_type& endpoint, AcceptHandler handler);

[function_requires `traits_type::has_accept`.]

[function_effects Calls `this->service.async_accept(this->implementation,
socket, &endpoint, handler)`.]

  void connect(const endpoint_type& endpoint);
  error_code connect(const endpoint_type& endpoint, error_code& ec);

[function_requires `traits_type::has_connect`.]

[function_returns `this->service.connect(this->implementation, endpoint, ec)`.]

  template<class ConnectHandler>
    void async_connect(const endpoint_type& endpoint, ConnectHandler handler);

[function_requires `traits_type::has_connect`.]

[function_effects Calls `this->service.async_connect(this->implementation,
endpoint, handler)`.]

  endpoint_type local_endpoint() const;
  endpoint_type local_endpoint(error_code& ec) const;

[function_requires `traits_type::has_local_endpoint`.]

[function_returns `this->service.local_endpoint(this->implementation, ec)`.]

  endpoint_type remote_endpoint() const;
  endpoint_type remote_endpoint(error_code& ec) const;

[function_requires `traits_type::has_remote_endpoint`.]

[function_returns `this->service.remote_endpoint(this->implementation, ec)`.]

  void shutdown(shutdown_type what);
  error_code shutdown(shutdown_type what, error_code& ec);

[function_requires `traits_type::has_shutdown`.]

[function_returns `this->service.shutdown(this->implementation, what, ec)`.]

  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers);
  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers,
                   error_code& ec);

[function_requires `traits_type::has_receive`.]

[function_returns `this->service.receive(this->implementation, buffers, 0, 0,
mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive(const MutableBufferSequence& buffers,
                       ReadHandler handler);

[function_requires `traits_type::has_receive`.]

[function_effects Calls `this->service.async_receive(this->implementation,
buffers, 0, 0, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers,
                   socket_base::message_flags flags);
  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers,
                   socket_base::message_flags flags, error_code& ec);

[function_requires `traits_type::has_receive`.]

[function_returns `this->service.receive(this->implementation, buffers, flags,
0, mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive(const MutableBufferSequence& buffers,
                       socket_base::message_flags flags,
                       ReadHandler handler);

[function_requires `traits_type::has_receive`.]

[function_effects Calls `this->service.async_receive(this->implementation,
buffers, flags, 0, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers,
                   socket_base::message_flags flags,
                   socket_base::message_flags& out_flags);
  template<class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers,
                   socket_base::message_flags flags,
                   socket_base::message_flags& out_flags,
                   error_code& ec);

[function_requires `traits_type::has_receive`.]

[function_returns `this->service.receive(this->implementation, buffers, flags,
&out_flags, mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive(const MutableBufferSequence& buffers,
                       socket_base::message_flags flags,
                       socket_base::message_flags& out_flags,
                       ReadHandler handler);

[function_requires `traits_type::has_receive`.]

[function_effects Calls `this->service.async_receive(this->implementation,
buffers, flags, &out_flags, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer>
      size_t receive(const MutableBufferSequence& buffers,
                     socket_base::message_flags flags,
                     socket_base::message_flags& out_flags,
                     const ConvertibleToMutableBuffer& control_data);
  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer>
      size_t receive(const MutableBufferSequence& buffers,
                     socket_base::message_flags flags,
                     socket_base::message_flags& out_flags,
                     const ConvertibleToMutableBuffer& control_data,
                     error_code& ec);

[function_requires `traits_type::has_receive`.]

[function_returns `this->service.receive(this->implementation, buffers, flags,
&out_flags, control_data, ec)`.]

  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer, class ReadHandler>
      void async_receive(const MutableBufferSequence& buffers,
                         socket_base::message_flags flags,
                         socket_base::message_flags& out_flags,
                         const ConvertibleToMutableBuffer& control_data,
                         ReadHandler handler);

[function_requires `traits_type::has_receive`.]

[function_effects Calls `this->service.async_receive(this->implementation,
buffers, flags, &out_flags, control_data, handler)`.]

  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender);
  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender, error_code& ec);

[function_requires `traits_type::has_receive_from`.]

[function_returns `this->service.receive_from(this->implementation, buffers,
sender, 0, 0, mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive_from(const MutableBufferSequence& buffers,
                            endpoint_type& sender,
                            ReadHandler handler);

[function_requires `traits_type::has_receive_from`.]

[function_effects Calls `this->service.async_receive_from(this->implementation,
buffers, sender, 0, 0, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender,
                        socket_base::message_flags flags);
  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender,
                        socket_base::message_flags flags,
                        error_code& ec);

[function_requires `traits_type::has_receive_from`.]

[function_returns `this->service.receive_from(this->implementation, buffers,
sender, flags, 0, mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive_from(const MutableBufferSequence& buffers,
                            endpoint_type& sender,
                            socket_base::message_flags flags,
                            ReadHandler handler);

[function_requires `traits_type::has_receive_from`.]

[function_effects Calls `this->service.async_receive_from(this->implementation,
buffers, sender, flags, 0, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender,
                        socket_base::message_flags flags,
                        socket_base::message_flags& out_flags);
  template<class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers,
                        endpoint_type& sender,
                        socket_base::message_flags flags,
                        socket_base::message_flags& out_flags,
                        error_code& ec);

[function_requires `traits_type::has_receive_from`.]

[function_returns `this->service.receive_from(this->implementation, buffers,
sender, flags, &out_flags, mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive_from(const MutableBufferSequence& buffers,
                            endpoint_type& sender,
                            socket_base::message_flags flags,
                            socket_base::message_flags& out_flags,
                            ReadHandler handler);

[function_requires `traits_type::has_receive_from`.]

[function_effects Calls `this->service.async_receive_from(this->implementation,
buffers, sender, flags, &out_flags, mutable_buffer(), handler)`.]

  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer>
      size_t receive_from(const MutableBufferSequence& buffers,
                          endpoint_type& sender,
                          socket_base::message_flags flags,
                          socket_base::message_flags& out_flags,
                          const ConvertibleToMutableBuffer&
                            control_data);
  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer>
      size_t receive_from(const MutableBufferSequence& buffers,
                          endpoint_type& sender,
                          socket_base::message_flags flags,
                          socket_base::message_flags& out_flags,
                          const ConvertibleToMutableBuffer&
                            control_data,
                          error_code& ec);

[function_requires `traits_type::has_receive_from`.]

[function_returns `this->service.receive_from(this->implementation, buffers,
sender, flags, &out_flags, control_data, ec)`.]

  template<class MutableBufferSequence,
    class ConvertibleToMutableBuffer, class ReadHandler>
      void async_receive_from(const MutableBufferSequence& buffers,
                              endpoint_type& sender,
                              socket_base::message_flags flags,
                              socket_base::message_flags& out_flags,
                              const ConvertibleToMutableBuffer&
                                control_data,
                              ReadHandler handler);

[function_requires `traits_type::has_receive_from`.]

[function_effects Calls `this->service.async_receive_from(this->implementation,
buffers, sender, flags, &out_flags, control_data, handler)`.]

  template<class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers);
  template<class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers,
                     error_code& ec);

[function_requires `traits_type::has_read_some`.]

[function_returns `this->service.receive(this->implementation, buffers, 0, 0,
mutable_buffer(), ec)`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_read_some(const MutableBufferSequence& buffers,
                         ReadHandler handler);

[function_requires `traits_type::has_read_some`.]

[function_effects Calls `this->service.async_receive(this->implementation,
buffers, 0, 0, mutable_buffer(), handler)`.]

  template<class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers);
  template<class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, error_code& ec);

[function_requires `traits_type::has_send`.]

[function_returns `this->service.send(this->implementation, buffers, 0,
const_buffer(), ec)`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_send(const ConstBufferSequence& buffers,
                    WriteHandler handler);

[function_requires `traits_type::has_send`.]

[function_effects Calls `this->service.async_send(this->implementation, buffers,
0, const_buffer(), handler)`.]

  template<class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers,
                socket_base::message_flags flags);
  template<class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers,
                socket_base::message_flags flags, error_code& ec);

[function_requires `traits_type::has_send`.]

[function_returns `this->service.send(this->implementation, buffers, flags,
const_buffer(), ec)`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_send(const ConstBufferSequence& buffers,
                    socket_base::message_flags flags,
                    WriteHandler handler);

[function_requires `traits_type::has_send`.]

[function_effects Calls `this->service.async_send(this->implementation, buffers,
flags, const_buffer(), handler)`.]

  template<class ConstBufferSequence, class ConvertibleToConstBuffer>
    size_t send(const ConstBufferSequence& buffers,
                socket_base::message_flags flags,
                const ConvertibleToConstBuffer& control_data);
  template<class ConstBufferSequence, class ConvertibleToConstBuffer>
    size_t send(const ConstBufferSequence& buffers,
                socket_base::message_flags flags,
                const ConvertibleToConstBuffer& control_data,
                error_code& ec);

[function_requires `traits_type::has_send`.]

[function_returns `this->service.send(this->implementation, buffers, flags,
control_data, ec)`.]

  template<class ConstBufferSequence, class ConvertibleToConstBuffer,
    class WriteHandler>
      void async_send(const ConstBufferSequence& buffers,
                      socket_base::message_flags flags,
                      const ConvertibleToConstBuffer& control_data,
                      WriteHandler handler);

[function_requires `traits_type::has_send`.]

[function_effects Calls `this->service.async_send(this->implementation, buffers,
flags, control_data, handler)`.]

  template<class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination);
  template<class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination, error_code& ec);

[function_requires `traits_type::has_send_to`.]

[function_returns `this->service.send_to(this->implementation, buffers,
destination, 0, const_buffer(), ec)`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_send_to(const ConstBufferSequence& buffers,
                       const endpoint_type& destination,
                       WriteHandler handler);

[function_requires `traits_type::has_send_to`.]

[function_effects Calls `this->service.async_send_to(this->implementation,
buffers, destination, 0, const_buffer(), handler)`.]

  template<class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination,
                   socket_base::message_flags flags);
  template<class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination,
                   socket_base::message_flags flags, error_code& ec);

[function_requires `traits_type::has_send_to`.]

[function_returns `this->service.send_to(this->implementation, buffers,
destination, flags, const_buffer(), ec)`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_send_to(const ConstBufferSequence& buffers,
                       const endpoint_type& destination,
                       socket_base::message_flags flags,
                       WriteHandler handler);

[function_requires `traits_type::has_send_to`.]

[function_effects Calls `this->service.async_send_to(this->implementation,
buffers, destination, flags, const_buffer(), handler)`.]

  template<class ConstBufferSequence, class ConvertibleToConstBuffer>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination,
                   socket_base::message_flags flags,
                   const ConvertibleToConstBuffer& control_data);
  template<class ConstBufferSequence, class ConvertibleToConstBuffer>
    size_t send_to(const ConstBufferSequence& buffers,
                   const endpoint_type& destination,
                   socket_base::message_flags flags,
                   const ConvertibleToConstBuffer& control_data,
                   error_code& ec);

[function_requires `traits_type::has_send_to`.]

[function_returns `this->service.send_to(this->implementation, buffers,
destination, flags, control_data, ec)`.]

  template<class ConstBufferSequence, class ConvertibleToConstBuffer,
    class WriteHandler>
      void async_send_to(const ConstBufferSequence& buffers,
                         const endpoint_type& destination,
                         socket_base::message_flags flags,
                         const ConvertibleToConstBuffer& control_data,
                         WriteHandler handler);

[function_requires `traits_type::has_send_to`.]

[function_effects Calls `this->service.async_send_to(this->implementation,
buffers, destination, flags, control_data, handler)`.]

  template<class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers);
  template<class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers,
                      error_code& ec);

[function_requires `traits_type::has_write_some`.]

[function_returns `this->service.send(this->implementation, buffers, 0,
const_buffer(), ec)`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_write_some(const ConstBufferSequence& buffers,
                          WriteHandler handler);

[function_requires `traits_type::has_write_some`.]

[function_effects Calls `this->service.async_send(this->implementation,
buffers, 0, const_buffer(), handler)`.]

[endsect]

[section [^basic_socket] convenience functions]

  template<class Protocol, class SocketTraits, class SocketService>
    void connect(basic_socket<Protocol,SocketTraits,SocketService>& s,
                 const typename Procotol::endpoint& e);
  template<class Protocol, class SocketTraits, class SocketService>
    error_code connect(
      basic_socket<Protocol,SocketTraits,SocketService>& s,
      const typename Procotol::endpoint& e, error_code& ec);

[function_requires `traits_type::has_connect` and `!s.is_open()`.]

[function_effects Behaves as if implemented as follows:
``
  s.open(e.protocol(), ec);
  if (!ec)
    s.connect(e, ec);
``]

[function_returns `ec`.]

  template<class Protocol, class SocketTraits, class SocketService,
    class ConnectHandler>
      void async_connect(
        basic_socket<Protocol,SocketTraits,SocketService>& s,
        const typename Procotol::endpoint& e, ConnectHandler handler);

[function_requires `traits_type::has_connect` and `!s.is_open()`.]

[function_effects /TODO/]

  template<class Protocol, class SocketTraits, class SocketService,
    class Iterator>
      void connect(basic_socket<Protocol,SocketTraits,SocketService>& s,
                   Iterator first, Iterator last);
  template<class Protocol, class SocketTraits, class SocketService,
    class Iterator>
      error_code connect(
        basic_socket<Protocol,SocketTraits,SocketService>& s,
        Iterator first, Iterator last, error_code& ec);

[function_requires `traits_type::has_connect` and `!s.is_open() && first !=
last`. `Iterator` is a forward iterator type, and the result of dereferencing
an object of type `Iterator` is convertible to the `Protocol::endpoint` type.]

[function_effects Behaves as if implemented as follows:
``
  while (first != last)
  {
    typename Protocol::endpoint e(*first);
    s.open(e.protocol(), ec);
    if (!ec)
      s.connect(e, ec);
    if (!ec)
      break;
    s.close(ec);
    if (ec)
      break;
    ++first;
  }
``]

[function_returns `ec`.]

  template<class Protocol, class SocketTraits, class SocketService,
    class Iterator, class ConnectHandler>
      void async_connect(
        basic_socket<Protocol,SocketTraits,SocketService>& s,
        Iterator first, Iterator last, ConnectHandler handler);

[function_requires `traits_type::has_connect` and `!s.is_open()`.]

[function_effects /TODO/]

[endsect]

[endsect]
