[section:deadline_timer_service Class template [^deadline_timer_service]]

Instances of the `deadline_timer_service` class template meet the requirements
of a [link requirements.timer_service `TimerService`].

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template<class Time, class TimeTraits>
        class deadline_timer_service :
          public io_service::service
        {
        public:
          static io_service::id id;

          // types:
          typedef TimeTraits traits_type;
          typedef Time time_type;
          typedef typename TimeTraits::duration_type duration_type;
          typedef ``['unspecified]`` implementation_type;

          // constructors:
          explicit deadline_timer_service(io_service& ios);

          // members:
          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          size_t cancel(implementation_type& impl, error_code& ec);

          time_type expires_at(const implementation_type& impl) const;

          size_t expires_at(implementation_type& impl, const time_type& t,
                            error_code& ec);

          duration_type expires_from_now(const implementation_type& impl) const;

          size_t expires_from_now(implementation_type& impl,
                                  const duration_type& d, error_code& ec);

          void wait(implementation_type& impl, error_code& ec);

          template<class WaitHandler>
            void async_wait(implementation_type& impl, WaitHandler handler);

        private:
          virtual void shutdown_service();
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

[section [^deadline_timer_service] constructors]

  explicit deadline_timer_service(io_service& ios);

[function_effects Constructs an object of class `deadline_timer_service<Time,
TimeTraits>`, initialising the base class with `io_service::service(ios)`.]

[endsect]

[section [^deadline_timer_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the timer implementation `impl`.]

  void destroy(implementation_type& impl);

[function_effects Cleans up resources owned by the timer implementation `impl`.
Cancels asynchronous wait operations associated with `impl` as if by performing:
``
  error_code ec;
  cancel(impl, ec);
``]

  size_t cancel(implementation_type& impl, error_code& ec);

[function_effects Causes any outstanding asynchronous wait operations to
complete as soon as possible. Handlers for cancelled operations shall be passed
the error code `errc::operation_canceled`.]

[function_returns The number of operations that were cancelled.]

  time_type expires_at(const implementation_type& impl) const;

[function_returns The expiry time associated with the timer implementation
`impl`, as previously set using `expires_at()` or `expires_from_now()`.]

  size_t expires_at(implementation_type& impl, const time_type& t,
                    error_code& ec);

[function_effects Sets the expiry time associated with the timer implementation
`impl`. Implicitly cancels asynchronous wait operations, as if by calling
`cancel(impl, ec)`.]

[function_returns The number of operations that were cancelled.]

[function_postconditions `expires_at(impl) == t`.]

  duration_type expires_from_now(const implementation_type& impl) const;

[function_returns A value equivalent to `TimeTraits::subtract(a.expires_at(b),
TimeTraits::now())`.]

  size_t expires_from_now(implementation_type& impl,
                          const duration_type& d, error_code& ec);

[function_effects Equivalent to `a.expires_at(b,
TimeTraits::add(TimeTraits::now(), d), ec)`.]

  void wait(implementation_type& impl, error_code& ec);
  
[function_effects Performs a synchronous wait operation associated with the
timer implementation `impl`.]

[function_postconditions `!!ec || !TimeTraits::lt(TimeTraits::now(),
a.expires_at(b))`.]

  template<class WaitHandler>
    void async_wait(implementation_type& impl, WaitHandler handler);

[function_effects Initiates an asynchronous wait operation that is performed
via the `io_service` object returned by `get_io_service()` and behaves according
to [link requirements.asynchronous_operations asynchronous operation]
requirements.]

[function_block The handler shall be posted for invocation only if the condition
`!!ec || !TimeTraits::lt(TimeTraits::now(), expires_at(impl))` holds, where
`ec` is the error code to be passed to the handler.]

[endsect]

[endsect]
