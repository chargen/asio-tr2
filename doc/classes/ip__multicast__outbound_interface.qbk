[section:ip__multicast__outbound_interface Class [^ip::multicast::outbound_interface]]
[xrefid internet.multicast.outbound]

The `outbound_interface` class represents a socket option that specifies the
network interface to use for outgoing multicast datagrams.

`outbound_interface` satisfies the requirements for `Destructible` (C++ Std,
[destructible]), `CopyConstructible` (C++ Std, [copyconstructible]),
`Assignable` (C++ Std, [assignable]), and [link
requirements.settable_socket_option `SettableSocketOption`].

  namespace std {
    namespace experimental {
      __begin_versioned_ns__
        namespace ip {
          namespace multicast {

            class outbound_interface
            {
            public:
              // constructors:
              explicit outbound_interface(const address_v4& network_interface) noexcept;
              explicit outbound_interface(unsigned int network_interface) noexcept;
            };

          } // namespace multicast
        } // namespace ip
      __end_versioned_ns__
    } // namespace experimental
  } // namespace std

Extensible implementations shall provide the following member functions:

  namespace std {
    namespace experimental {
      __begin_versioned_ns__
        namespace ip {
          namespace multicast {

            class outbound_interface
            {
            public:
              template<class Protocol> int level(const Protocol& p) const noexcept;
              template<class Protocol> int name(const Protocol& p) const noexcept;
              template<class Protocol> const void* data(const Protocol& p) const noexcept;
              template<class Protocol> size_t size(const Protocol& p) const noexcept;
              // ``['remainder unchanged]``
            private:
                in_addr v4_value_; // ``['exposition only]``
                unsigned int v6_value_; // ``['exposition only]``
            };

          } // namespace multicast
        } // namespace ip
      __end_versioned_ns__
    } // namespace experimental
  } // namespace std

[commentary The `outbound_interface` class is a `SettableSocketOption` only,
unlike its __POSIX__ equivalents which are both gettable and settable. This is
to avoid the need for additional classes that provide a protocol independent
representation of a network interface.]

Let [^['L]] and [^['N]] identify __POSIX__ macros to be passed as the /level/ and
/option_name/ arguments, respectively, to __POSIX__ __setsockopt__ and
__getsockopt__. In the table below, `p` denotes a (possibly const) value of a
type meeting the [link requirements.protocol protocol] requirements, as passed
to the socket option's `level` and `name` member functions.

[table outbound_interface socket option
  [[['L] if `p.family() == AF_INET4`][['N] if `p.family() == AF_INET4`]
   [['L] if `p.family() == AF_INET6`][['N] if `p.family() == AF_INET6`]]
  [
    [`IPPROTO_IP`]
    [`IP_MULTICAST_TTL`]
    [`IPPROTO_IPV6`]
    [`IPV6_MULTICAST_HOPS`]
  ]
]

[function_note The constants `IPPROTO_IP`, `IPPROTO_IPV6`, and
`IPV6_MULTICAST_IF` are defined in the __POSIX__ header file __netinet_in_h__.]

[commentary Where is `IP_MULTICAST_IF` in __POSIX__?]

[section [^ip::multicast::outbound_interface] constructors]
[xrefid internet.multicast.outbound.cons]

  explicit outbound_interface(const address_v4& network_interface) noexcept;

[function_effects For extensible implementations, `v4_value_` is initialized to
correspond to the IPv4 address `network_interface`, and `v6_value_` is
zero-initialized.]

  explicit outbound_interface(unsigned int network_interface) noexcept;

[function_effects For extensible implementations, `v6_value_` is initialized to
`network_interface`, and `v4_value_` is zero-initialized.]

[endsect]

[section [^ip::multicast::outbound_interface] members (extensible implementations)]
[xrefid internet.multicast.outbound.extensible]

  template<class Protocol> int level(const Protocol& p) const noexcept;

[function_returns ['[*`L`]].]

  template<class Protocol> int name(const Protocol& p) const noexcept;

[function_returns ['[*`N`]].]

  template<class Protocol> const void* data(const Protocol& p) const noexcept;

[function_returns `std::addressof(v6_value_)` if `p.family() == AF_INET6`,
otherwise `std::addressof(v4_value_)`.]

  template<class Protocol> size_t size(const Protocol& p) const noexcept;

[function_returns `sizeof(v6_value_)` if `p.family() == AF_INET6`, otherwise
`sizeof(v4_value_)`.]

[endsect]

[endsect]
