[section:io_service__strand Class [^io_service::strand]]

  namespace std {
    namespace tr2 {
      namespace sys {

        class io_service::strand
        {
        public:
          // constructors/destructor:
          explicit strand(std::tr2::sys::io_service& ios);
          ~strand();

          // members:
          std::tr2::sys::io_service& io_service();

          template<class CompletionHandler>
            void dispatch(CompletionHandler handler);

          template<class CompletionHandler>
            void post(CompletionHandler handler);

          template<class Handler>
            ``['unspecified]`` wrap(Handler handler);

        private:
          strand(const strand&);         // not defined
          void operator=(const strand&); // not defined
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

An object of class `io_service::strand` may be used to prevent concurrent
invocation of handlers.

Given:

[mdash] An `io_service` object `i`.

[mdash] A `strand` object `s` constructed using `s(i)`.

[mdash] An object `a` meeting [link requirements.completion_handler completion
handler] requirements, where `a` is passed to the `strand` by performing either
`s.dispatch(a)` or `s.post(a)`. For this discussion `a` and all copies of `a`
are considered equivalent.

[mdash] An object `b` meeting [link requirements.completion_handler completion
handler] requirements, where `b` is passed to the `strand` by performing either
`s.dispatch(b)` or `s.post(b)`. For this discussion `b` and all copies of `b`
are considered equivalent.

[mdash] An arbitrary function object `x` that is valid in the expression `x()`.

[mdash] An arbitrary function object `y` that is valid in the expression `y()`.

[mdash] An arbitrary thread /thread1/ that is calling any overload of `run()`,
`run_one()`, `poll()` or `poll_one()` for the `io_service` object `i`.

[mdash] An arbitrary thread /thread2/ that is calling any overload of `run()`,
`run_one()`, `poll()` or `poll_one()` for the `io_service` object `i`.

The implementation shall ensure that, if /thread1/ performs
`io_handler_dispatch(x, &a)`, /thread2/ does not concurrently perform
`io_handler_dispatch(y, &b)`.

/TODO:/ Sequence points to define concurrency? Memory barriers?

[std_note No requirements are made on implementations with respect to:\n\n

[mdash] whether handlers dispatched through different `strand` objects may or
may not be invoked concurrently; or\n\n

[mdash] the order of invocation of handler objects dispatched through a
`strand`.]

[section [^io_service::strand] constructors/destructor]

  explicit strand(std::tr2::sys::io_service& ios);

[function_effects Constructs an object of class `strand`.]

[function_postconditions `&io_service() == &ios`.]

  ~strand();

[function_effects Destroys an object of class `strand`. Handlers posted through
the strand that have not yet been invoked will still be dispatched in a way
that meets the guarantee of non-concurrency.]

[endsect]

[section [^io_service::strand] members]

  std::tr2::sys::io_service& io_service();

[function_returns The `io_service` associated with the strand.]

  template<class CompletionHandler>
    void dispatch(CompletionHandler handler);

[function_effects If the current thread is invoking a handler for the `strand`
object `*this`, performs `io_handler_invoke(handler, &handler)`. Otherwise,
requests invocation of the handler as if by performing
`io_service().dispatch(handler)`, with the additional requirement of
non-concurrent handler invocation as defined above.]

[function_block If the invoked handler throws an exception, the exception shall
be allowed to propagate to the caller of `dispatch()`. The `io_service` and
`strand` states shall be equivalent to if the handler had been successfully
invoked without throwing an exception.]

  template<class CompletionHandler>
    void post(CompletionHandler handler);

[function_effects Requests invocation of the handler as if by performing
`io_service().post(handler)`, with the additional requirement of non-concurrent
handler invocation as defined above.]

  template<class Handler>
    ``['unspecified]`` wrap(Handler handler);

[function_returns An object `f` of an unspecified type `F` meeting [link
requirements.handler handler] requirements, and constructed using `F(*this,
handler)`, where `F` behaves as if defined as follows:
``
  class F
  {
  public:
    F(strand& s, Handler h)
      : strand_(s), handler_(h) {}

    template<class T1, class T2, __dotdotdot__, class TN>
    class GN
    {
    public:
      GN(Handler h, T1 t1, T2 t2, __dotdotdot__, TN tN)
        : handler_(h), t1_(t1), t2_(t2), __dotdotdot__, tN_(tN) {}

      void operator()() { handler_(t1_, t2_, __dotdotdot__, tN_); }

      friend void* io_handler_allocate(size_t size, GN* this_g)
      {
        return io_handler_allocate(size, &this_g->handler_);
      }

      friend void io_handler_deallocate(void* pointer, size_t size, GN* this_g)
      {
        io_handler_deallocate(pointer, size, &this_g->handler_);
      }

      template<class Function>
      friend void io_handler_invoke(Function func, GN* this_g)
      {
        io_handler_invoke(func, &this_g->handler_);
      }

    private:
      Handler handler_;
      T1 t1_; T2 t2_; __dotdotdot__; TN tN_;
    };

    template<class T1, class T2, __dotdotdot__, class TN>
    void operator()(T1 t1, T2 t2, __dotdotdot__, TN tN)
    {
      strand_.dispatch(GN<T1,T2,__dotdotdot__,TN>(handler_, t1, t2, __dotdotdot__, tN));
    }

    friend void* io_handler_allocate(size_t size, F* this_f)
    {
      return io_handler_allocate(size, &this_f->handler_);
    }

    friend void io_handler_deallocate(void* pointer, size_t size, F* this_f)
    {
      io_handler_deallocate(pointer, size, &this_f->handler_);
    }

    template<class Function>
    class H
    {
    public:
      H(Function f, Handler h)
        : function_(f), handler_(h) {}

      void operator()()
      {
        function_();
      }

      friend void* io_handler_allocate(size_t size, H* this_h)
      {
        return io_handler_allocate(size, &this_h->handler_);
      }

      friend void io_handler_deallocate(void* pointer, size_t size, H* this_h)
      {
        io_handler_deallocate(pointer, size, &this_h->handler_);
      }

      template<class Function1>
      friend void io_handler_invoke(Function1 func, H* this_h)
      {
        io_handler_invoke(func, &this_h->handler_);
      }

    private:
      Function function_;
      Handler handler_;
    };

    template<class Function>
    friend void io_handler_invoke(Function func, F* this_f)
    {
      this_f->strand_.dispatch(H<Function>(func, this_f->handler_));
    }

  private:
    strand& strand_;
    Handler handler_;
  };
``]

[function_block [inline_note In practical terms, the effect of `f(v1, v2,
__dotdotdot__, vN)` is to cause the `io_service` associated with the `strand`
to perform `handler(v1, v2, __dotdotdot__, vN)` from within a call to `run()`,
`run_one()`, `poll()` or `poll_one()`, subject to the requirements of
non-concurrent handler invocation as defined above.\n\n

Similarly, the effect of `io_handler_invoke(g, &f)` is to cause the
`io_service` to perform `g()` from within a call to `run()`, `run_one()`,
`poll()` or `poll_one()`, subject to the requirements of non-concurrent handler
invocation as defined above.]]

[endsect]

[endsect]
