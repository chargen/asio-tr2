[section:handler_traits Struct template [^handler_traits]]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template <class Handler> struct handler_traits {
          typedef Handler handler_type;

          template <class E = system_executor>
          struct executor {
            typedef ``['see below]`` type;
          };

          template <class E = system_executor>
          using executor_t = typename executor<E>::type;

          template <class E = system_executor>
            static executor_t<E> get_executor(
              const Handler& h, const E& ex = E()) noexcept;

          template <class A = allocator<void>>
          struct allocator {
            typedef ``['see below]`` type;
          };

          template <class A = allocator<void>>
          using allocator_t = typename allocator<A>::type;

          template <class A = allocator<void>>
            static allocator_t<A> get_allocator(
              const Handler& h, const A& a = A()) noexcept;
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

Template argument `Handler` is a handler type produced by `handler_type_t<T,
S>` for some completion token type `T` and call signature `S`.

A program may specialize this traits type if the `Handler` template parameter
in the specialization is a user-defined type.

Specializations of `handler_traits` shall satisfy the requirements in the table
below. In this table, `X` is a specialization of `handler_traits` for the
template parameter `Handler`; `h` is a const reference to an object of type
`Handler`; `ex` is an object of a type `E` meeting [link requirements.executor
Executor requirements]; and `a` is an object of a type `A` meeting `Allocator`
requirements (C++ Std, [allocator.requirements]).

[table handler_traits specialization requirements
  [[Expression][Return type][Note]]
  [
    [`X::handler_type`]
    [`Handler`]
    []
  ]
  [
    [`typename X::template executor<>::type`]
    [A type meeting [link requirements.executor Executor requirements].]
    []
  ]
  [
    [`typename X::template executor<E>::type`]
    [A type meeting [link requirements.executor Executor requirements].]
    []
  ]
  [
    [`X::executor_t<>`]
    [`typename X::template executor<>::type`]
    []
  ]
  [
    [`X::executor_t<E>`]
    [`typename X::template executor<E>::type`]
    []
  ]
  [
    [`X::get_executor(h)`]
    [`X::executor_t<>`]
    []
  ]
  [
    [`X::get_executor(h, ex)`]
    [`X::executor_t<E>`]
    []
  ]
  [
    [`typename X::template allocator<>::type`]
    [A type meeting `Allocator` requirements (C++ Std, \[allocator.requirements\]).]
    []
  ]
  [
    [`typename X::template allocator<A>::type`]
    [A type meeting `Allocator` requirements (C++ Std, \[allocator.requirements\]).]
    []
  ]
  [
    [`X::allocator_t<>`]
    [`typename X::template allocator<>::type`]
    []
  ]
  [
    [`X::allocator_t<A>`]
    [`typename X::template allocator<A>::type`]
    []
  ]
  [
    [`X::get_allocator(h)`]
    [`X::allocator_t<>`]
    []
  ]
  [
    [`X::get_allocator(h, a)`]
    [`X::allocator_t<A>`]
    []
  ]
]

[section [^handler_traits] members]

  template <class E = system_executor>
  struct executor {
    typedef ``['see below]`` type;
  };

[function_type\n
[mdash] if `Handler` and `decay_t<Handler>` are different types,
`handler_traits<decay_t<Handler>>::executor_t<E>`;\n
[mdash] otherwise, if `Handler` has a nested type `executor_type`, `typename
Handler::executor_type`;\n
[mdash] otherwise `E`.]

  template <class E = system_executor>
    static executor_t<E> get_executor(
      const Handler& h, const E& ex = E()) noexcept;

[function_returns\n
[mdash] if `Handler` and `decay_t<Handler>` are different types,
`handler_traits<decay_t<Handler>>::get_executor(h, ex)`;\n
[mdash] otherwise, if `Handler` has a nested type `executor_type`,
`h.get_executor()`;\n
[mdash] otherwise `ex`.]

  template <class A = allocator<void>>
  struct allocator {
    typedef ``['see below]`` type;
  };

[function_type\n
[mdash] if `Handler` and `decay_t<Handler>` are different types,
`handler_traits<decay_t<Handler>>::allocator_t<A>`;\n
[mdash] otherwise, if `Handler` has a nested type `allocator_type`, `typename
Handler::allocator_type`;\n
[mdash] otherwise `A`.]

  template <class A = allocator<void>>
    static allocator_t<A> get_allocator(
      const Handler& h, const A& a = A()) noexcept;

[function_returns\n
[mdash] if `Handler` and `decay_t<Handler>` are different types,
`handler_traits<decay_t<Handler>>::get_allocator(h, a)`;\n
[mdash] otherwise, if `Handler` has a nested type `allocator_type`,
`h.get_allocator()`;\n
[mdash] otherwise `a`.]

[endsect]

[endsect]
