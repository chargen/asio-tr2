[section:ip__multicast__group_socket_options Multicast group management socket options]
[xrefid internet.multicast.group]

The `ip::multicast::join_group` and `ip::multicast::leave_group` classes are
socket options for multicast group management.

Multicast group management socket option classes satisfy the requirements for
`Destructible` (C++ Std, [destructible]), `CopyConstructible` (C++ Std,
[copyconstructible]), `Assignable` (C++ Std, [assignable]), and [link
requirements.settable_socket_option `SettableSocketOption`].

[std_example Creating a UDP socket and joining a multicast group:
``
  // Open an IPv4 UDP socket bound to a specific port.
  ip::udp::endpoint ep(ip::udp::v4(), 12345);
  ip::udp::socket sock(io_svc, ep);

  // Join a multicast group.
  ip::address addr = ip::make_address("239.255.0.1");
  sock.set_option(ip::multicast::join_group(addr));
``]

Multicast group management socket option classes shall be defined as follows:

  class ``['[*C]]``
  {
  public:
    // constructors:
    explicit ``['[*C]]``(const address& multicast_group) noexcept;
    explicit ``['[*C]]``(const address_v4& multicast_group,
               const address_v4& network_interface = address_v4::any()) noexcept;
    explicit ``['[*C]]``(const address_v6& multicast_group,
               unsigned int network_interface = 0) noexcept;
  };

Extensible implementations shall provide the following member functions:

  class ``['[*C]]``
  {
  public:
    template<class Protocol> int level(const Protocol& p) const noexcept;
    template<class Protocol> int name(const Protocol& p) const noexcept;
    template<class Protocol> const void* data(const Protocol& p) const noexcept;
    template<class Protocol> size_t size(const Protocol& p) const noexcept;
    // ``['remainder unchanged]``
  private:
    ip_mreq v4_value_; // ``['exposition only]``
    ipv6_mreq v6_value_; // ``['exposition only]``
  };

Let [^['L]] and [^['N]] identify __POSIX__ macros to be passed as the /level/ and
/option_name/ arguments, respectively, to __POSIX__ __setsockopt__ and
__getsockopt__. In the table below, `p` denotes a (possibly const) value of a
type meeting the [link requirements.protocol protocol] requirements, as passed
to the socket option's `level` and `name` member functions.

[table Multicast group management socket options
  [[['C]]
   [['L] if `p.family() == AF_INET4`][['N] if `p.family() == AF_INET4`]
   [['L] if `p.family() == AF_INET6`][['N] if `p.family() == AF_INET6`]]
  [
    [`ip::multicast::join_group`]
    [`IPPROTO_IP`]
    [`IP_ADD_MEMBERSHIP`]
    [`IPPROTO_IPV6`]
    [`IPV6_JOIN_GROUP`]
  ]
  [
    [`ip::multicast::leave_group`]
    [`IPPROTO_IP`]
    [`IP_DROP_MEMBERSHIP`]
    [`IPPROTO_IPV6`]
    [`IPV6_LEAVE_GROUP`]
  ]
]

[std_note The constants `IPPROTO_IP` and `IPPROTO_IPV6` are defined in the
__POSIX__ header file __netinet_in_h__. The constants `IPV6_JOIN_GROUP` and
`IPV6_LEAVE_GROUP` are defined in the __POSIX__ header file __netinet_in_h__.]

[commentary Where are `IP_ADD_MEMBERSHIP` and `IP_DROP_MEMBERSHIP` in
__POSIX__?]

[section Multicast group management socket option constructors]
[xrefid internet.multicast.group.cons]

  explicit ``['[*C]]``(const address& multicast_group) noexcept;

[function_effects If `multicast_group.is_v6()` is `true`, calls
[^['[*C]]]`(multicast_group.to_v6())`; otherwise, calls
[^['[*C]]]`(multicast_group.to_v4())`.]

  explicit ``['[*C]]``(const address_v4& multicast_group,
             const address_v4& network_interface = address_v4::any()) noexcept;

[function_effects For extensible implementations, `v4_value_.imr_multiaddr` is
initialized to correspond to the address `multicast_group`,
`v4_value_.imr_interface` is initialized to correspond to address
`network_interface`, and `v6_value_` is zero-initialized.]

  explicit ``['[*C]]``(const address_v6& multicast_group,
             unsigned int network_interface = 0) noexcept;

[function_effects For extensible implementations, `v6_value_.ipv6mr_multiaddr`
is initialized to correspond to the address `multicast_group`,
`v6_value_.ipv6mr_interface` is initialized to `network_interface`, and
`v4_value_` is zero-initialized.]

[endsect]

[section Multicast group management socket option members (extensible implementations)]
[xrefid internet.multicast.group.extensible]

  template<class Protocol> int level(const Protocol& p) const noexcept;

[function_returns ['[*`L`]].]

  template<class Protocol> int name(const Protocol& p) const noexcept;

[function_returns ['[*`N`]].]

  template<class Protocol> const void* data(const Protocol& p) const noexcept;

[function_returns `std::addressof(v6_value_)` if `p.family() == AF_INET6`, otherwise
`std::addressof(v4_value_)`.]

  template<class Protocol> size_t size(const Protocol& p) const noexcept;

[function_returns `sizeof(v6_value_)` if `p.family() == AF_INET6`, otherwise
`sizeof(v4_value_)`.]

[endsect]

[endsect]
