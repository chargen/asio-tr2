[section:stream_socket_service Class template [^stream_socket_service]]

Instances of the `stream_socket_service` class template meet the requirements
of a [link requirements.stream_socket_service `StreamSocketService`].

  namespace std {
    namespace experimental {
      namespace network {

        template<class Protocol>
        class stream_socket_service :
          public io_service::service
        {
        public:
          static io_service::id id;

          // types:
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef ``['unspecified]`` implementation_type;
          typedef ``['implementation defined]`` native_type;

          // constructors:
          explicit stream_socket_service(io_service& ios);

          // members:
          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          error_code open(implementation_type& impl,
                          const protocol_type& protocol, error_code& ec);

          error_code assign(implementation_type& impl,
                            const protocol_type& protocol,
                            const native_type& native_socket, error_code& ec);

          bool is_open(const implementation_type& impl) const;

          error_code close(implementation_type& impl, error_code& ec);

          native_type native(implementation_type& impl);

          error_code cancel(implementation_type& impl, error_code& ec);

          template<class SettableSocketOption>
            error_code set_option(implementation_type& impl,
                                  const SettableSocketOption& option,
                                  error_code& ec);

          template<class GettableSocketOption>
            error_code get_option(const implementation_type& impl,
                                  GettableSocketOption& option,
                                  error_code& ec) const;

          template<class IoControlCommand>
            error_code io_control(implementation_type& impl,
                                  IoControlCommand& command, error_code& ec);

          bool at_mark(const implementation_type& impl, error_code& ec) const;

          size_t available(const implementation_type& impl,
                           error_code& ec) const;

          error_code bind(implementation_type& impl,
                          const endpoint_type& endpoint, error_code& ec);

          error_code shutdown(implementation_type& impl, shutdown_type how,
                              error_code& ec);

          endpoint_type local_endpoint(const implementation_type& impl,
                                       error_code& ec) const;

          endpoint_type remote_endpoint(const implementation_type& impl,
                                        error_code& ec) const;

          error_code connect(implementation_type& impl,
                             const endpoint_type& endpoint, error_code& ec);

          template<class ConnectHandler>
            void async_connect(implementation_type& impl,
                               const endpoint_type& endpoint,
                               ConnectHandler handler);

          template<class MutableBufferSequence>
            size_t receive(implementation_type& impl,
                           const MutableBufferSequence& buffers,
                           socket_base::message_flags flags,
                           error_code& ec);

          template<class MutableBufferSequence, class ReadHandler>
            void async_receive(implementation_type& impl,
                               const MutableBufferSequence& buffers,
                               socket_base::message_flags flags,
                               ReadHandler handler);

          template<class ConstBufferSequence>
            size_t send(implementation_type& impl,
                        const ConstBufferSequence& buffers,
                        socket_base::message_flags flags,
                        error_code& ec);

          template<class ConstBufferSequence, class WriteHandler>
            void async_send(implementation_type& impl,
                            const ConstBufferSequence& buffers,
                            socket_base::message_flags flags,
                            WriteHandler handler);

        private:
          virtual void shutdown_service();
        };

      } // namespace network
    } // namespace experimental
  } // namespace std

[section [^stream_socket_service] types]

  typedef ``['implementation defined]`` native_type;

[function_block The native representation of a socket. Must satisfy the
requirements of `CopyConstructible` types (C++ Std, 20.1.3), and the
requirements of `Assignable` types (C++ Std, 23.1). [inline_note For __POSIX__
implementations, this type would typically be convertible to and from `int`.
For __Windows__ implementations, this type would typically be convertible to
and from `SOCKET`.]]

[endsect]

[section [^stream_socket_service] constructors]

  explicit stream_socket_service(io_service& ios);

[function_effects Constructs an object of class
`stream_socket_service<Protocol>`, initialising the base class
with `io_service::service(ios)`.]

[endsect]

[section [^stream_socket_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the socket implementation `impl`.]

[function_postconditions `!is_open(impl)`.]

  void destroy(implementation_type& impl);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, disables the linger socket option to prevent
the operation from blocking, and releases socket resources as if by __POSIX__
__close__. Otherwise, no effect. Handlers for cancelled asynchronous operations
are passed the `error_code` value `error::operation_canceled`. Failures are
ignored.]

  error_code open(implementation_type& impl,
                  const protocol_type& protocol, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`error::already_open`. Otherwise establishes the postcondition, as if by
__POSIX__ __socket__.]

[function_returns `ec`.]

[function_postconditions `is_open(impl)`.]

  error_code assign(implementation_type& impl,
                    const protocol_type& protocol,
                    const native_type& native_socket, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`error::already_open`. Otherwise assigns the existing socket to the
implementation `impl`.]

[function_returns `ec`.]

[function_postconditions `is_open(impl)`.]

[commentary The main source of errors for `assign` would be a call to register
the socket with an OS-specific event demultiplexor, such as a `kqueue`, an
`epoll` descriptor, a `/dev/poll` device, or a __Windows__ I/O completion port.
These errors may also be produced by `open`, since that function would perform
the same registration.]

  bool is_open(const implementation_type& impl) const;

[function_returns A `bool` indicating whether the socket implementation `impl`
was opened by a previous call to `open` or `assign`.]

  error_code close(implementation_type& impl, error_code& ec);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and establishes the postcondition as if by
__POSIX__ __close__. Otherwise, no effect. Handlers for cancelled asynchronous
operations are passed the `error_code` value `error::operation_canceled`.]

[function_returns `ec`.]

  native_type native(implementation_type& impl);

[function_returns The native representation of the socket implementation
`impl`.]

  error_code cancel(implementation_type& impl, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise cancels pending asynchronous operations
associated with `impl`, if any. Handlers for cancelled asynchronous operations
are passed the `error_code` value `error::operation_canceled`.]

[function_block The conditions under which cancellation of asynchronous
operations is permitted are implementation-defined. If current conditions do
not permit cancellation, an implementation shall set `ec` to
`error::operation_not_supported`.]

[commentary This flexibility is included to support implementations on
__Windows__ versions prior to Vista, where the `CancelIo` function will only
cancel asynchronous operations started from the same thread. Vista provides
`CancelIoEx` which may be used to cancel all asynchronous operations associated
with a socket.]

[function_returns `ec`.]

  template<class SettableSocketOption>
    error_code set_option(implementation_type& impl,
                          const SettableSocketOption& option,
                          error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise sets an option on the socket `impl`, as
if by __POSIX__ __setsockopt__.]

[function_returns `ec`.]

  template<class GettableSocketOption>
    error_code get_option(const implementation_type& impl,
                          GettableSocketOption& option,
                          error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise gets an option from the socket `impl`,
as if by __POSIX__ __getsockopt__.]

[function_returns `ec`.]

  template<class IoControlCommand>
    error_code io_control(implementation_type& impl,
                          IoControlCommand& command, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise executes an I/O control command on the
socket `impl`, as if by __POSIX__ __ioctl__.]

[function_returns `ec`.]

[commentary This proposal does not include any classes that satisfy [link
requirements.io_control_command `IoControlCommand`] requirements. However,
implementation-specific extensions such as QoS may be implemented using
`ioctl()`, and the `io_control()` operation is included to allow these
extensions to be supported.]

  bool at_mark(const implementation_type& impl, error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. If the value returned by `native(impl)` is not a
valid socket, sets `ec` to `error::not_a_socket`. [inline_note Instead of
__POSIX__ `ENOTTY`.] Otherwise determines if the socket `impl` is at the
out-of-band data mark, as if by __POSIX__ __sockatmark__.]

[function_returns A `bool` indicating whether the socket is at the out-of-band
data mark.]

  size_t available(const implementation_type& impl,
                   error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise determines the number of bytes that may
be read without blocking.]

[function_returns The number of bytes that may be read without blocking, or 0
if an error occurs.]

  error_code bind(implementation_type& impl,
                  const endpoint_type& endpoint, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise binds the socket `impl` to the
specified local endpoint, as if by __POSIX__ __bind__.]

[function_returns `ec`.]

  error_code shutdown(implementation_type& impl, shutdown_type how,
                      error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise shuts down all or part of a full-duplex
connection for the socket `impl`, as if by __POSIX__ __shutdown__. If `how` is
`shutdown_receive`, uses __POSIX__ `SHUT_RD`. If `how` is `shutdown_send`, uses
__POSIX__ `SHUT_WR`. If `how` is `shutdown_both`, uses __POSIX__ `SHUT_RDWR`.]

[function_returns `ec`.]

  endpoint_type local_endpoint(const implementation_type& impl,
                               error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise determines the locally-bound endpoint
associated with the socket `impl`, as if by __POSIX__ __getsockname__.]

[function_returns On success, the locally-bound endpoint associated with
`impl`. Otherwise `endpoint_type()`.]

  endpoint_type remote_endpoint(const implementation_type& impl,
                                error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise determines the remote endpoint
associated with the socket `impl`, as if by __POSIX__ __getpeername__.]

[function_returns On success, the remote endpoint associated with `impl`.
Otherwise `endpoint_type()`.]

  error_code connect(implementation_type& impl,
                     const endpoint_type& endpoint, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise connects the socket `impl` to the
specified remote endpoint, as if by __POSIX__ __connect__.]

[function_returns `ec`.]

  template<class ConnectHandler>
    void async_connect(implementation_type& impl,
                       const endpoint_type& endpoint,
                       ConnectHandler handler);

[function_requires `is_open(impl)`.]

[function_effects Initiates an asynchronous operation to connect the socket
`impl` to the specified remote endpoint, as if by __POSIX__ __connect__. The
operation is performed via the `io_service` object returned by
`get_io_service()` and behaves according to [link
requirements.asynchronous_operations asynchronous operation] requirements.]

[function_block If `is_open(impl)` is false, the operation shall fail
immediately with `error_code` value `error::bad_file_descriptor`.]

[function_block When multiple asynchronous connect operations are initiated
such that the operations may logically be performed in parallel, the behaviour
is implementation-defined. When an asynchronous connect operation and an
asynchronous read or write operation are initiated such that they may logically
be performed in parallel, the behaviour is implementation-defined.]

[function_block If a program performs a synchronous `set_option`, `io_control`,
`bind`, `shutdown`, `connect`, `receive`, or `send` operation on `impl` while
there is an incomplete asynchronous connect operation, the behaviour is
implementation-defined.]

  template<class MutableBufferSequence>
    size_t receive(implementation_type& impl,
                   const MutableBufferSequence& buffers,
                   socket_base::message_flags flags,
                   error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise reads data from a connected socket
`impl`, as if by __POSIX__ __recvmsg__.]

[function_block The mutable buffer sequence `buffers` specifies memory where
the data should be placed. The operation shall always fill a buffer in the
sequence completely before proceeding to the next. If the total size of all
buffers in the sequence `buffers` is `0`, the function shall return `0`
immediately.]

[function_block The `flags` argument specifies the type of receive operation to be performed.]

[function_block If the operation completes due to graceful connection closure
by the peer, the operation shall fail with `error::eof`.]

[function_returns On success, the number of bytes read. Otherwise `0`.]

  template<class MutableBufferSequence, class ReadHandler>
    void async_receive(implementation_type& impl,
                       const MutableBufferSequence& buffers,
                       socket_base::message_flags flags,
                       ReadHandler handler);

[function_requires `is_open(impl) && (flags & socket_base::message_peek) == 0`.]

[function_effects Initiates an asynchronous operation to read data from a
connected socket `impl`, as if by __POSIX__ __recvmsg__. The operation is
performed via the `io_service` object returned by `get_io_service()` and
behaves according to [link requirements.asynchronous_operations asynchronous
operation] requirements.]

[function_block If `is_open(impl)` is false, the operation shall fail
immediately with `error_code` value `error::bad_file_descriptor`.]

[function_block The mutable buffer sequence `buffers` specifies memory where
the data should be placed. The operation shall always fill a buffer in the
sequence completely before proceeding to the next. The implementation shall
maintain one or more copies of `buffers` until such time as the read operation
no longer requires access to the memory specified by the buffers in the
sequence. The program must ensure the memory is valid until:]

[function_block [mdash] the last copy of `buffers` is destroyed, or]

[function_block [mdash] the handler for the asynchronous read operation is
invoked,]

[function_block whichever comes first. If the total size of all buffers in the
sequence `buffers` is `0`, the asynchronous read operation shall complete
immediately and pass `0` as the argument to the handler that specifies the
number of bytes read.]

[function_block The `flags` argument specifies the type of receive operation to
be performed. If `flags & socket_base::message_peek` is true, the operation
shall fail immediately with `error::invalid_argument`. If `flags &
socket_base::message_out_of_band` is true, the operation shall continue until
out-of-band data is received, or an error occurs.]

[function_block When multiple asynchronous read operations with zero `flags`
are initiated such that the operations may logically be performed in parallel,
the implementation shall fill the `buffers` in the order in which the
operations were issued. The order of invocation of the handlers for these
operations is implementation-defined. When multiple asynchronous read
operations with non-zero `flags` are initiated such that operations may
logically be performed in parallel, the behaviour is implementation-defined.]

[function_block If a program performs a synchronous `set_option`, `io_control`,
`bind`, `shutdown`, `connect`, or `receive` operation on `impl` while there is
an incomplete asynchronous read operation, the behaviour is
implementation-defined.]

[function_block If the operation completes due to graceful connection closure
by the peer, the operation shall fail with `error::eof`.]

[function_block If the operation completes successfully, the `ReadHandler`
object `handler` is invoked with the number of bytes transferred. Otherwise
it is invoked with `0`.]

  template<class ConstBufferSequence>
    size_t send(implementation_type& impl,
                const ConstBufferSequence& buffers,
                socket_base::message_flags flags,
                error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_file_descriptor`. Otherwise writes data to a connected socket
`impl`, as if by __POSIX__ __sendmsg__.]

[function_block The constant buffer sequence `buffers` specifies memory where
the data to be written is located. The operation shall always write a buffer in
the sequence completely before proceeding to the next. If the total size of all
buffers in the sequence `buffers` is `0`, the function shall return `0`
immediately.]

[function_block The `flags` argument specifies the type of send operation to be
performed.]

[function_returns On success, the number of bytes written. Otherwise `0`.]

  template<class ConstBufferSequence, class WriteHandler>
    void async_send(implementation_type& impl,
                    const ConstBufferSequence& buffers,
                    socket_base::message_flags flags,
                    WriteHandler handler);

[function_requires `is_open(impl)`.]

[function_effects Initiates an asynchronous operation to write data to a
connected socket `impl`, as if by __POSIX__ __sendmsg__. The operation is
performed via the `io_service` object returned by `get_io_service()` and
behaves according to [link requirements.asynchronous_operations asynchronous
operation] requirements.]

[function_block If `is_open(impl)` is false, the operation shall fail
immediately with `error_code` value `error::bad_file_descriptor`.]

[function_block The constant buffer sequence `buffers` specifies memory where
the data to be written is located. The operation shall always write a buffer in
the sequence completely before proceeding to the next. The implementation shall
maintain one or more copies of `buffers` until such time as the write operation
no longer requires access to the memory specified by the buffers in the
sequence. The program must ensure the memory is valid until:]

[function_block [mdash] the last copy of `buffers` is destroyed, or]

[function_block [mdash] the handler for the asynchronous write operation is
invoked,]

[function_block whichever comes first. If the total size of all buffers in the
sequence `buffers` is `0`, the asynchronous write operation shall complete
immediately and pass `0` as the argument to the handler that specifies the
number of bytes written.]

[function_block The `flags` argument specifies the type of send operation to
be performed.]

[function_block When multiple asynchronous write operations with zero `flags`
are initiated such that the operations may logically be performed in parallel,
the implementation shall write the `buffers` in the order in which the
operations were issued. The order of invocation of the handlers for these
operations is implementation-defined. When multiple asynchronous write
operations with non-zero `flags` are initiated such that operations may
logically be performed in parallel, the behaviour is implementation-defined.]

[function_block If a program performs a synchronous `set_option`, `io_control`,
`bind`, `shutdown`, `connect`, or `send` operation on `impl` while there is an
incomplete asynchronous send operation, the behaviour is
implementation-defined.]

[function_block If the operation completes successfully, the `WriteHandler`
object `handler` is invoked with the number of bytes transferred. Otherwise
it is invoked with `0`.]

[endsect]

[endsect]
