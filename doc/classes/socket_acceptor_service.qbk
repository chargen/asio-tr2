[section:socket_acceptor_service Class template [^socket_acceptor_service]]

Instances of the `socket_acceptor_service` class template meet the requirements
of an [link requirements.acceptor_service `AcceptorService`].

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Protocol>
        class socket_acceptor_service :
          public io_service::service
        {
        public:
          // types:
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef ``['[*unspecified]]`` implementation_type;
          typedef ``['[*implementation-defined]]`` native_type;

          // constructors:
          explicit socket_acceptor_service(io_service& ios);

          // members:
          void shutdown_service();

          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          error_code open(implementation_type& impl,
                          const protocol_type& protocol, error_code& ec);

          error_code assign(implementation_type& impl,
                            const protocol_type& protocol,
                            const native_type& native_socket, error_code& ec);

          bool is_open(const implementation_type& impl) const;

          error_code close(implementation_type& impl, error_code& ec);

          native_type native(implementation_type& impl);

          error_code cancel(implementation_type& impl, error_code& ec);

          template<class SettableSocketOption>
            error_code set_option(implementation_type& impl,
                                  const SettableSocketOption& option,
                                  error_code& ec);

          template<class GettableSocketOption>
            error_code get_option(const implementation_type& impl,
                                  GettableSocketOption& option,
                                  error_code& ec) const;

          template<class IoControlCommand>
            error_code io_control(implementation_type& impl,
                                  IoControlCommand& command, error_code& ec);

          bool is_blocking(const implementation_type& impl,
                           error_code& ec) const;

          error_code set_blocking(implementation_type& impl, bool block,
                                  error_code& ec);

          error_code bind(implementation_type& impl,
                          const endpoint_type& endpoint, error_code& ec);

          error_code listen(implementation_type& impl, int backlog,
                            error_code& ec);

          endpoint_type local_endpoint(const implementation_type& impl,
                                       error_code& ec) const;

          template<class SocketService>
            error_code accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type* endpoint, error_code& ec);

          template<class SocketService, class AcceptHandler>
            void async_accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type* endpoint, AcceptHandler handler);
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

[section [^socket_acceptor_service] constructors]

  explicit socket_acceptor_service(io_service& ios);

[function_effects Constructs an object of class
`socket_acceptor_service<Protocol>`, initialising the base class with
`io_service::service(ios)`.]

[endsect]

[section [^socket_acceptor_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the socket acceptor implementation `impl`.]

[function_postconditions `!is_open(impl)`.]

  void destroy(implementation_type& impl);

[function_effects Cleans up resources owned by the socket acceptor
implementation `impl`. Implicitly cancels asynchronous accept operations
associated with `impl` and closes the socket acceptor.]

  error_code open(implementation_type& impl,
                  const protocol_type& protocol, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects Establishes the postcondition, as if by __POSIX__ __socket__.
On success, sets `ec` such that the expression `!ec` is true. On failure, an
implementation shall set `ec` to the `error_code` value corresponding to the
failure condition, as shown in the table below. For failure conditions not
listed, an implementation is permitted to set `ec` to any other value such that
the expression `!ec` is false.]

[table Table--open() failure conditions
  [[failure condition][error code]]
  [
    [`is_open(impl)`.]
    [`error::already_open`]
  ]
  [
    [The implementation does not support the address family specified by the
     `protocol` value.]
    [`error::address_family_not_supported`]
  ]
  [
    [No more sockets are available for the process.]
    [`error::no_descriptors`]
  ]
  [
    [No more sockets are available for the system.]
    [`error::no_system_descriptors`]
  ]
  [
    [The implementation does not support the protocol specified by the
     `protocol` value, or does not support the protocol in conjunction with the
     address family specified by the `protocol` value.]
    [`error::protocol_not_supported`]
  ]
  [
    [The implementation does not support the socket type specified by the
     `protocol` value, or does not support the socket type in conjunction with
     the protocol specified by the `protocol` value.]
    [`error::socket_type_not_supported`]
  ]
]

[function_returns `ec`.]

[function_postconditions `is_open(impl) && is_blocking(impl, err) && !err`,
  where `err` is a value of type `error_code`.]

  error_code assign(implementation_type& impl,
                    const protocol_type& protocol,
                    const native_type& native_socket, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects Assigns the existing socket acceptor to the implementation
`impl`. On success, sets `ec` such that the expression `!ec` is true. On
failure, an implementation shall set `ec` to any value such that the expression
`!ec` is false.]

[function_returns `ec`.]

[function_postconditions `is_open(impl)`.]

[commentary The main source of errors for `assign` would be a call to register
the socket acceptor with an OS-specific event demultiplexor, such as a
`kqueue`, an `epoll` descriptor, a `/dev/poll` device, or a __Windows__ I/O
completion port. These errors may also be produced by `open`, since that
function would perform the same registration.]

  bool is_open(const implementation_type& impl) const;

[function_returns A `bool` indicating whether the socket acceptor
implementation `impl` was opened by a previous call to `open` or `assign`.]

  error_code close(implementation_type& impl, error_code& ec);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and establishes the postcondition as if by
__POSIX__ __close__. Otherwise, no effect. Handlers for cancelled asynchronous
operations are passed the `error_code` value `error::operation_aborted`. On
success, sets `ec` such that the expression `!ec` is true. On failure, an
implementation shall set `ec` to the `error_code` value corresponding to the
failure condition, as shown in the table below. For failure conditions not
listed, an implementation is permitted to set `ec` to any other value such that
the expression `!ec` is false.]

[table Table--close() failure conditions
  [[failure condition][error code]]
  [
    [The native socket acceptor implementation returned by `native(impl)` is
    not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [Operation interrupted by signal.]
    [`error::interrupted`]
  ]
]

[function_returns `ec`.]

[function_postconditions `!is_open(impl)`.]

  native_type native(implementation_type& impl);

[function_returns The native representation of the socket acceptor
implementation `impl`.]

  error_code cancel(implementation_type& impl, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects Cancels pending asynchronous operations associated with
`impl`, if any. Handlers for cancelled asynchronous operations are passed the
`error_code` value `error::operation_aborted`. On success, sets `ec` such that
the expression `!ec` is true. On failure, an implementation shall set `ec` to
the `error_code` value corresponding to the failure condition, as shown in the
table below. For failure conditions not listed, an implementation is permitted
to set `ec` to any other value such that the expression `!ec` is false.]

[function_block The conditions under which cancellation of asynchronous
operations is permitted are implementation-defined. If current conditions do
not permit cancellation, an implementation shall set `ec` to
`error::not_supported`.]

[commentary This flexibility is included to support implementations on
__Windows__ versions prior to Vista, where the `CancelIo` function will only
cancel asynchronous operations started from the same thread. Vista provides
`CancelIoEx` which may be used to cancel all asynchronous operations associated
with a socket.]

[table Table--cancel() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [Pending asynchronous operations may not be cancelled at this time.]
    [`error::not_supported`]
  ]
]

[function_returns `ec`.]

  template<class SettableSocketOption>
    error_code set_option(implementation_type& impl,
                          const SettableSocketOption& option,
                          error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects Sets an option on the socket acceptor `impl`, as if by
__POSIX__ __setsockopt__. On success, sets `ec` such that the expression `!ec`
is true. On failure, an implementation shall set `ec` to the `error_code` value
corresponding to the failure condition, as shown in the table below. For
failure conditions not listed, an implementation is permitted to set `ec` to
any other value such that the expression `!ec` is false.]

[table Table--set_option() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The option is not supported by the protocol.]
    [`error::no_protocol_option`]
  ]
  [
    [The socket option name `option.name()` is not valid at the specified
    socket option level `option.level()`.]
    [`error::invalid_argument`]
  ]
]

[function_returns `ec`.]

  template<class GettableSocketOption>
    error_code get_option(const implementation_type& impl,
                          GettableSocketOption& option,
                          error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects Gets an option from the socket acceptor `impl`, as if by
__POSIX__ __getsockopt__. On success, sets `ec` such that the expression `!ec`
is true. On failure, an implementation shall set `ec` to the `error_code` value
corresponding to the failure condition, as shown in the table below. For
failure conditions not listed, an implementation is permitted to set `ec` to
any other value such that the expression `!ec` is false.]

[table Table--get_option() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The option is not supported by the protocol.]
    [`error::no_protocol_option`]
  ]
  [
    [The socket option name `option.name()` is not valid at the specified
    socket option level `option.level()`.]
    [`error::invalid_argument`]
  ]
]

[function_returns `ec`.]

  template<class IoControlCommand>
    error_code io_control(implementation_type& impl,
                          IoControlCommand& command, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects Executes an I/O control command on the socket acceptor
`impl`, as if by __POSIX__ __ioctl__. On success, sets `ec` such that the
expression `!ec` is true. On failure, an implementation shall set `ec` to the
`error_code` value corresponding to the failure condition, as shown in the
table below. For failure conditions not listed, an implementation is permitted
to set `ec` to any other value such that the expression `!ec` is false.]

[table Table--io_control() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The I/O control command name or data is invalid for the socket acceptor.]
    [`error::invalid_argument`]
  ]
  [
    [Operation interrupted by signal.]
    [`error::interrupted`]
  ]
]

[function_returns `ec`.]

  bool is_blocking(const implementation_type& impl,
                   error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects Determines whether synchronous accept operations on the
socket acceptor `impl` must block (that is, they are not permitted to fail with
`error::would_block`), as if by __POSIX__ __fcntl__ with command `F_GETFL` to
check whether the `O_NONBLOCKING` flag is unset. On success, sets `ec` such
that the expression `!ec` is true. On failure, an implementation shall set `ec`
to the `error_code` value corresponding to the failure condition, as shown in
the table below. For failure conditions not listed, an implementation is
permitted to set `ec` to any other value such that the expression `!ec` is
false.]

[table Table--is_blocking() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
]

[function_returns `true` if the operation succeeded and synchronous operations
must block. Otherwise, `false`.]

  error_code set_blocking(implementation_type& impl, bool block,
                          error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects Sets whether synchronous operations on the socket acceptor
`impl` must block (that is, they are not permitted to fail with
`error::would_block`), as if by __POSIX__ __fcntl__ with command `F_SETFL` to
clear or set the `O_NONBLOCKING` flag. On success, sets `ec` such that the
expression `!ec` is true. On failure, an implementation shall set `ec` to the
`error_code` value corresponding to the failure condition, as shown in the
table below. For failure conditions not listed, an implementation is permitted
to set `ec` to any other value such that the expression `!ec` is false.]

[table Table--set_blocking() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
]

[function_returns `ec`.]

[function_postconditions `is_blocking(impl, err) && !err`, where `err` is a
value of type `error_code`.]

  error_code bind(implementation_type& impl,
                  const endpoint_type& endpoint, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects Establishes the postcondition as if by __POSIX__ __bind__. On
success, sets `ec` such that the expression `!ec` is true. On failure, an
implementation shall set `ec` to the `error_code` value corresponding to the
failure condition, as shown in the table below. For failure conditions not
listed, an implementation is permitted to set `ec` to any other value such that
the expression `!ec` is false.]

[table Table--bind() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The specified endpoint is already in use.]
    [`error::address_in_use`]
  ]
  [
    [The specified endpoint is not available from the local machine.]
    [`error::address_not_available`]
  ]
  [
    [The specified endpoint is not valid for the address family of the socket
    acceptor's protocol.]
    [`error::address_family_not_supported`]
  ]
  [
    [The socket acceptor has already been bound, and does not support binding to
    a new endpoint.]
    [`error::invalid_argument`]
  ]
  [
    [The socket type of the socket acceptor's protocol does not support
    binding.]
    [`error::not_supported`]
  ]
]

[function_returns `ec`.]

[function_postconditions `local_endpoint(impl, err) == endpoint && !err`, where
`err` is a value of type `error_code`.]

  error_code listen(implementation_type& impl, int backlog,
                    error_code& ec);

[function_effects Marks the socket acceptor `impl` as ready to accept
connections, as if by __POSIX__ __listen__. If `backlog <= 0`, the
implementation shall set the socket acceptor's listen queue to the maximum
allowable length. On success, sets `ec` such that the expression `!ec` is true.
On failure, an implementation shall set `ec` to the `error_code` value
corresponding to the failure condition, as shown in the table below. For
failure conditions not listed, an implementation is permitted to set `ec` to
any other value such that the expression `!ec` is false.]

[table Table--listen() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The socket acceptor is not locally-bound, and the protocol does not
    support listening on an unbound socket acceptor.]
    [`error::address_required`]
  ]
  [
    [The socket type of the socket acceptor's protocol does not support
    listening.]
    [`error::not_supported`]
  ]
]

[function_returns `ec`.]

  endpoint_type local_endpoint(const implementation_type& impl,
                               error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects Determines the locally-bound endpoint associated with the
socket acceptor `impl`, as if by __POSIX__ __getsockname__. On success, sets
`ec` such that the expression `!ec` is true. On failure, an implementation
shall set `ec` to the `error_code` value corresponding to the failure
condition, as shown in the table below. For failure conditions not listed, an
implementation is permitted to set `ec` to any other value such that the
expression `!ec` is false.]

[table Table--local_endpoint() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The socket acceptor's protocol does not support the operation.]
    [`error::not_supported`]
  ]
]

[function_returns The locally-bound endpoint associated with `impl`.]

  template<class SocketService>
    error_code accept(implementation_type& impl,
                      basic_socket<Protocol, SocketService>& socket,
                      endpoint_type* endpoint, error_code& ec);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects Associates `socket` with the first connection extracted from
the queue of pending connections of the socket acceptor `impl`, as if by
__POSIX__ __accept__. On success, sets `ec` such that the expression `!ec` is
true, and if `endpoint != 0`, assigns into `*endpoint` the remote endpoint of
the connection. On failure, an implementation shall set `ec` to the
`error_code` value corresponding to the failure condition, as shown in the
table below. For failure conditions not listed, an implementation is permitted
to set `ec` to any other value such that the expression `!ec` is false.]

[table Table--accept() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The socket acceptor's protocol does not support the operation.]
    [`error::not_supported`]
  ]
  [
    [The socket acceptor is not accepting connections.]
    [`error::invalid_argument`]
  ]
  [
    [No more sockets are available for the process.]
    [`error::no_descriptors`]
  ]
  [
    [No more sockets are available for the system.]
    [`error::no_system_descriptors`]
  ]
  [
    [The socket acceptor has been marked as non-blocking and no connections are
    ready to be accepted.]
    [`error::would_block`]
  ]
  [
    [Operation interrupted by signal.]
    [`error::interrupted`]
  ]
]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted (such as __POSIX__
`ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or `ERROR_NETNAME_DELETED`).]

[function_returns `ec`.]

[function_postconditions `socket.is_open()`.]

  template<class SocketService, class AcceptHandler>
    void async_accept(implementation_type& impl,
                      basic_socket<Protocol, SocketService>& socket,
                      endpoint_type* endpoint, AcceptHandler handler);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects Initiates an asynchronous operation to associate `socket`
with the first connection extracted from the queue of pending connections of
the socket acceptor `impl`, as if by __POSIX__ __accept__. The operation is
performed via the `io_service` object returned by
`io_service::service::io_service()` and behaves according to [link
requirements.asynchronous_operations asynchronous operation] requirements.]

[function_block The program must ensure the `basic_socket<>` object `socket` is
valid until the handler for the asynchronous operation is invoked. If `endpoint
!= 0`, the program must ensure the object `*endpoint` is valid until the
handler for the asynchronous operation is invoked.]

[function_block On completion of the asynchronous operation, the
`AcceptHandler` object `handler` shall be invoked with an `error_code` value
`ec`. On success, `ec` shall contain a value such that the expression `!ec` is
true, and `socket.is_open()` shall be true. On failure, an implementation shall
pass as `ec` the `error_code` value corresponding to the failure condition, as
shown in the table below. For failure conditions not listed, an implementation
is permitted to pass as `ec` any other value such that the expression `!ec` is
false.]

[table Table--async_accept() failure conditions
  [[failure condition][error code]]
  [
    [`!is_open(impl)`, or the native socket acceptor implementation returned
    by `native(impl)` is not valid.]
    [`error::bad_descriptor`]
  ]
  [
    [The native implementation returned by `native(impl)` is not a valid socket
    acceptor.]
    [`error::not_socket`]
  ]
  [
    [The socket acceptor's protocol does not support the operation.]
    [`error::not_supported`]
  ]
  [
    [The socket acceptor is not accepting connections.]
    [`error::invalid_argument`]
  ]
  [
    [No more sockets are available for the process.]
    [`error::no_descriptors`]
  ]
  [
    [No more sockets are available for the system.]
    [`error::no_system_descriptors`]
  ]
]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted (such as __POSIX__
`ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or `ERROR_NETNAME_DELETED`).]

[endsect]

[endsect]
