[section:socket_acceptor_service Class template [^socket_acceptor_service]]

Instances of the `socket_acceptor_service` class template meet the requirements
of an [link requirements.acceptor_service `AcceptorService`].

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Protocol>
        class socket_acceptor_service :
          public io_service::service
        {
        public:
          // types:
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef ``['[*unspecified]]`` implementation_type;
          typedef ``['[*unspecified]]`` native_type;

          // constructors:
          explicit socket_acceptor_service(io_service& ios);

          // members:
          void shutdown_service();

          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          error_code open(implementation_type& impl,
                          const protocol_type& protocol, error_code& ec);

          error_code assign(implementation_type& impl,
                            const protocol_type& protocol,
                            const native_type& native_socket, error_code& ec);

          error_code close(implementation_type& impl, error_code& ec);

          native_type native(implementation_type& impl);

          template<class SettableSocketOption>
            error_code set_option(implementation_type& impl,
                                  const SettableSocketOption& option,
                                  error_code& ec);

          template<class GettableSocketOption>
            error_code get_option(const implementation_type& impl,
                                  GettableSocketOption& option,
                                  error_code& ec) const;

          template<class IoControlCommand>
            error_code io_control(implementation_type& impl,
                                  IoControlCommand& command, error_code& ec);

          bool blocking(const implementation_type& impl, error_code& ec) const;

          error_code blocking(implementation_type& impl, bool block,
                              error_code& ec);

          error_code bind(implementation_type& impl,
                          const endpoint_type& endpoint, error_code& ec);

          error_code listen(implementation_type& impl, int backlog,
                            error_code& ec);

          endpoint_type local_endpoint(const implementation_type& impl,
                                       error_code& ec) const;

          template<class SocketService>
            error_code accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              error_code& ec);
          template<class SocketService, class AcceptHandler>
            void async_accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              AcceptHandler handler);

          template<class SocketService>
            error_code accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type& endpoint, error_code& ec);
          template<class SocketService, class AcceptHandler>
            void async_accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type& endpoint, AcceptHandler handler);
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

[endsect]
