[section:socket_acceptor_service Class template [^socket_acceptor_service]]

Instances of the `socket_acceptor_service` class template meet the requirements
of a [link requirements.socket_acceptor_service `SocketAcceptorService`].

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template<class Protocol>
        class socket_acceptor_service :
          public io_service::service
        {
        public:
          static io_service::id id;

          // types:
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef ``['unspecified]`` implementation_type;
          typedef ``['implementation defined]`` native_handle_type;

          // constructors:
          explicit socket_acceptor_service(io_service& ios);

          // members:
          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          void open(implementation_type& impl,
                    const protocol_type& protocol, error_code& ec);

          void assign(implementation_type& impl, const protocol_type& protocol,
                      const native_handle_type& native_socket, error_code& ec);

          bool is_open(const implementation_type& impl) const;

          void close(implementation_type& impl, error_code& ec);

          native_handle_type native_handle(implementation_type& impl);

          void cancel(implementation_type& impl, error_code& ec);

          template<class SettableSocketOption>
            void set_option(implementation_type& impl,
                            const SettableSocketOption& option, error_code& ec);

          template<class GettableSocketOption>
            void get_option(const implementation_type& impl,
                            GettableSocketOption& option, error_code& ec) const;

          template<class IoControlCommand>
            void io_control(implementation_type& impl,
                            IoControlCommand& command, error_code& ec);

          void bind(implementation_type& impl,
                    const endpoint_type& endpoint, error_code& ec);

          void listen(implementation_type& impl, int backlog, error_code& ec);

          endpoint_type local_endpoint(const implementation_type& impl,
                                       error_code& ec) const;

          template<class SocketService>
            void accept(implementation_type& impl,
                        basic_socket<Protocol, SocketService>& socket,
                        endpoint_type* endpoint, error_code& ec);

          template<class SocketService, class AcceptHandler>
            void async_accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type* endpoint, AcceptHandler handler);

        private:
          virtual void shutdown_service();
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

[section [^socket_acceptor_service] types]

  typedef ``['implementation defined]`` native_handle_type;

[function_block The native representation of a socket acceptor. Must satisfy
the requirements of `CopyConstructible` types (C++ Std, 20.1.3), and the
requirements of `Assignable` types (C++ Std, 23.1). [inline_note For __POSIX__
implementations, this type would typically be convertible to and from `int`.
For __Windows__ implementations, this type would typically be convertible to
and from `SOCKET`.]]

[endsect]

[section [^socket_acceptor_service] constructors]

  explicit socket_acceptor_service(io_service& ios);

[function_effects Constructs an object of class
`socket_acceptor_service<Protocol>`, initialising the base class with
`io_service::service(ios)`.]

[endsect]

[section [^socket_acceptor_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the socket acceptor implementation `impl`.]

[function_postconditions `!is_open(impl)`.]

  void destroy(implementation_type& impl);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and releases socket acceptor resources as if
by __POSIX__ __close__. Otherwise, no effect. Handlers for cancelled
asynchronous operations are passed the `error_code` value
`errc::operation_canceled`. Failures are ignored.]

  void open(implementation_type& impl,
            const protocol_type& protocol, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`TBD_errc::already_open`. Otherwise establishes the postcondition, as if by
__POSIX__ __socket__.]

[function_postconditions `is_open(impl)`.]

  void assign(implementation_type& impl, const protocol_type& protocol,
              const native_handle_type& native_socket, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`TBD_errc::already_open`. Otherwise assigns the existing socket acceptor to the
implementation `impl`.]

[function_postconditions `is_open(impl)`.]

[commentary The main source of errors for `assign` would be a call to register
the socket acceptor with an OS-specific event demultiplexor, such as a
`kqueue`, an `epoll` descriptor, a `/dev/poll` device, or a __Windows__ I/O
completion port. These errors may also be produced by `open`, since that
function would perform the same registration.]

  bool is_open(const implementation_type& impl) const;

[function_returns A `bool` indicating whether the socket acceptor
implementation `impl` was opened by a previous call to `open` or `assign`.]

  void close(implementation_type& impl, error_code& ec);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and establishes the postcondition as if by
__POSIX__ __close__. Otherwise, no effect. Handlers for cancelled asynchronous
operations are passed the `error_code` value `errc::operation_canceled`.]

[function_postconditions `!is_open(impl)`.]

  native_handle_type native_handle(implementation_type& impl);

[function_returns The native representation of the socket acceptor
implementation `impl`.]

  void cancel(implementation_type& impl, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise cancels pending asynchronous operations
associated with `impl`, if any. Handlers for cancelled asynchronous operations
are passed the `error_code` value `errc::operation_canceled`.]

[function_block The conditions under which cancellation of asynchronous
operations is permitted are implementation-defined. If current conditions do
not permit cancellation, an implementation shall set `ec` to
`errc::operation_not_supported`.]

[commentary This flexibility is included to support implementations on
__Windows__ versions prior to Vista, where the `CancelIo` function will only
cancel asynchronous operations started from the same thread. Vista provides
`CancelIoEx` which may be used to cancel all asynchronous operations associated
with a socket.]

  template<class SettableSocketOption>
    void set_option(implementation_type& impl,
                    const SettableSocketOption& option, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise sets an option on the socket acceptor
`impl`, as if by __POSIX__ __setsockopt__.]

  template<class GettableSocketOption>
    void get_option(const implementation_type& impl,
                    GettableSocketOption& option, error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise gets an option from the socket acceptor
`impl`, as if by __POSIX__ __getsockopt__.]

  template<class IoControlCommand>
    void io_control(implementation_type& impl,
                    IoControlCommand& command, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise executes an I/O control command on the
socket acceptor `impl`, as if by __POSIX__ __ioctl__.]

[commentary This proposal does not include any classes that satisfy [link
requirements.io_control_command `IoControlCommand`] requirements. However,
implementation-specific extensions such as QoS may be implemented using
`ioctl()`, and the `io_control()` operation is included to allow these
extensions to be supported.]

  void bind(implementation_type& impl,
            const endpoint_type& endpoint, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise binds the socket `impl` to the specified
local endpoint, as if by __POSIX__ __bind__.]

  void listen(implementation_type& impl, int backlog, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwse marks the socket acceptor `impl` as
ready to accept connections, as if by __POSIX__ __listen__. If `backlog ==
socket_base::max_connections`, the implementation shall set the socket
acceptor's listen queue to the maximum allowable length.]

  endpoint_type local_endpoint(const implementation_type& impl,
                               error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. Otherwise determines the locally-bound endpoint
associated with the socket acceptor `impl`, as if by __POSIX__
__getsockname__.]

[function_returns On success, the locally-bound endpoint associated with
`impl`. Otherwise `endpoint_type()`.]

  template<class SocketService>
    void accept(implementation_type& impl,
                basic_socket<Protocol, SocketService>& socket,
                endpoint_type* endpoint, error_code& ec);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`errc::bad_file_descriptor`. If `socket.is_open()` is true, sets `ec` to
`TBD_errc::already_open`. Otherwise associates `socket` with the first connection
extracted from the queue of pending connections of the socket acceptor `impl`,
as if by __POSIX__ __accept__. On success, and if `endpoint != 0`, and if
`endpoint != 0`, assigns into `*endpoint` the remote endpoint of the
connection.]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted. [inline_note Such as
__POSIX__ `ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or
`ERROR_NETNAME_DELETED`).]]

[commentary The `ECONNABORTED` error is suppressed since it is a transient
error, is rarely (if ever) useful but handling it correctly adds complexity to
even very simple servers.]

[function_postconditions `socket.is_open()`.]

  template<class SocketService, class AcceptHandler>
    void async_accept(implementation_type& impl,
                      basic_socket<Protocol, SocketService>& socket,
                      endpoint_type* endpoint, AcceptHandler handler);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects Initiates an asynchronous operation to associate `socket`
with the first connection extracted from the queue of pending connections of
the socket acceptor `impl`, as if by __POSIX__ __accept__. The operation is
performed via the `io_service` object returned by `get_io_service()` and
behaves according to [link requirements.asynchronous_operations asynchronous
operation] requirements.]

[function_block If `is_open(impl)` is false, the operation shall fail
immediately with `error_code` value `errc::bad_file_descriptor`. If
`socket.is_open()` is true, the operation shall fail immediately with
`error_code` value `TBD_errc::already_open`.]

[function_block When multiple asynchronous accept operations are initiated such
that the operations may logically be performed in parallel, the behaviour is
implementation-defined.]

[function_block If a program performs a synchronous `set_option`, `io_control`,
`bind`, or `accept` operation on `impl` while there is an incomplete
asynchronous accept operation, the behaviour is implementation-defined.]

[function_block The program must ensure the `basic_socket<>` object `socket` is
valid until the handler for the asynchronous operation is invoked. If `endpoint
!= 0`, the program must ensure the object `*endpoint` is valid until the
handler for the asynchronous operation is invoked.]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted. [inline_note Such as
__POSIX__ `ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or
`ERROR_NETNAME_DELETED`).]]

[endsect]

[endsect]
