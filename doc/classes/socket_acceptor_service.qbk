[section:socket_acceptor_service Class template [^socket_acceptor_service]]

Instances of the `socket_acceptor_service` class template meet the requirements
of a [link requirements.socket_acceptor_service `SocketAcceptorService`].

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Protocol>
        class socket_acceptor_service :
          public io_service::service
        {
        public:
          static io_service::id id;

          // types:
          typedef Protocol protocol_type;
          typedef typename Protocol::endpoint endpoint_type;
          typedef ``['unspecified]`` implementation_type;
          typedef ``['implementation defined]`` native_type;

          // constructors:
          explicit socket_acceptor_service(io_service& ios);

          // members:
          void construct(implementation_type& impl);

          void destroy(implementation_type& impl);

          error_code open(implementation_type& impl,
                          const protocol_type& protocol, error_code& ec);

          error_code assign(implementation_type& impl,
                            const protocol_type& protocol,
                            const native_type& native_socket, error_code& ec);

          bool is_open(const implementation_type& impl) const;

          error_code close(implementation_type& impl, error_code& ec);

          native_type native(implementation_type& impl);

          error_code cancel(implementation_type& impl, error_code& ec);

          template<class SettableSocketOption>
            error_code set_option(implementation_type& impl,
                                  const SettableSocketOption& option,
                                  error_code& ec);

          template<class GettableSocketOption>
            error_code get_option(const implementation_type& impl,
                                  GettableSocketOption& option,
                                  error_code& ec) const;

          template<class IoControlCommand>
            error_code io_control(implementation_type& impl,
                                  IoControlCommand& command, error_code& ec);

          error_code bind(implementation_type& impl,
                          const endpoint_type& endpoint, error_code& ec);

          error_code listen(implementation_type& impl, int backlog,
                            error_code& ec);

          endpoint_type local_endpoint(const implementation_type& impl,
                                       error_code& ec) const;

          template<class SocketService>
            error_code accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type* endpoint, error_code& ec);

          template<class SocketService, class AcceptHandler>
            void async_accept(implementation_type& impl,
                              basic_socket<Protocol, SocketService>& socket,
                              endpoint_type* endpoint, AcceptHandler handler);

        private:
          virtual void shutdown_service();
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

[section [^socket_acceptor_service] types]

  typedef ``['implementation defined]`` native_type;

[function_block The native representation of a socket acceptor. Must satisfy
the requirements of `CopyConstructible` types (C++ Std, 20.1.3), and the
requirements of `Assignable` types (C++ Std, 23.1). For __POSIX__
implementations, must be convertible to and from `int`. For __Windows__
implementations, must be convertible to and from `SOCKET`.]

[endsect]

[section [^socket_acceptor_service] constructors]

  explicit socket_acceptor_service(io_service& ios);

[function_effects Constructs an object of class
`socket_acceptor_service<Protocol>`, initialising the base class with
`io_service::service(ios)`.]

[endsect]

[section [^socket_acceptor_service] members]

  void shutdown_service();

[function_effects Destroys all copies of user-defined handler objects owned by
the service.]

  void construct(implementation_type& impl);

[function_effects Initialises the socket acceptor implementation `impl`.]

[function_postconditions `!is_open(impl)`.]

  void destroy(implementation_type& impl);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and releases socket acceptor resources as if
by __POSIX__ __close__. Otherwise, no effect. Handlers for cancelled
asynchronous operations are passed the `error_code` value
`error::operation_aborted`. Failures are ignored.]

  error_code open(implementation_type& impl,
                  const protocol_type& protocol, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`error::already_open`. Otherwise establishes the postcondition, as if by
__POSIX__ __socket__.]

[function_returns `ec`.]

[function_postconditions `is_open(impl)`.]

  error_code assign(implementation_type& impl,
                    const protocol_type& protocol,
                    const native_type& native_socket, error_code& ec);

[function_requires `!is_open(impl)`.]

[function_effects If `is_open(impl)` is true, sets `ec` to
`error::already_open`. Otherwise assigns the existing socket acceptor to the
implementation `impl`.]

[function_returns `ec`.]

[function_postconditions `is_open(impl)`.]

[commentary The main source of errors for `assign` would be a call to register
the socket acceptor with an OS-specific event demultiplexor, such as a
`kqueue`, an `epoll` descriptor, a `/dev/poll` device, or a __Windows__ I/O
completion port. These errors may also be produced by `open`, since that
function would perform the same registration.]

  bool is_open(const implementation_type& impl) const;

[function_returns A `bool` indicating whether the socket acceptor
implementation `impl` was opened by a previous call to `open` or `assign`.]

  error_code close(implementation_type& impl, error_code& ec);

[function_effects If `is_open(impl)` is true, cancels pending asynchronous
operations associated with `impl`, and establishes the postcondition as if by
__POSIX__ __close__. Otherwise, no effect. Handlers for cancelled asynchronous
operations are passed the `error_code` value `error::operation_aborted`.]

[function_returns `ec`.]

[function_postconditions `!is_open(impl)`.]

  native_type native(implementation_type& impl);

[function_returns The native representation of the socket acceptor
implementation `impl`.]

  error_code cancel(implementation_type& impl, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwise cancels pending asynchronous operations
associated with `impl`, if any. Handlers for cancelled asynchronous operations
are passed the `error_code` value `error::operation_aborted`.]

[function_block The conditions under which cancellation of asynchronous
operations is permitted are implementation-defined. If current conditions do
not permit cancellation, an implementation shall set `ec` to
`error::not_supported`.]

[commentary This flexibility is included to support implementations on
__Windows__ versions prior to Vista, where the `CancelIo` function will only
cancel asynchronous operations started from the same thread. Vista provides
`CancelIoEx` which may be used to cancel all asynchronous operations associated
with a socket.]

[function_returns `ec`.]

  template<class SettableSocketOption>
    error_code set_option(implementation_type& impl,
                          const SettableSocketOption& option,
                          error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwise sets an option on the socket acceptor
`impl`, as if by __POSIX__ __setsockopt__.]

[function_returns `ec`.]

  template<class GettableSocketOption>
    error_code get_option(const implementation_type& impl,
                          GettableSocketOption& option,
                          error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwise gets an option from the socket acceptor
`impl`, as if by __POSIX__ __getsockopt__.]

[function_returns `ec`.]

  template<class IoControlCommand>
    error_code io_control(implementation_type& impl,
                          IoControlCommand& command, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwise executes an I/O control command on the
socket acceptor `impl`, as if by __POSIX__ __ioctl__.]

[function_returns `ec`.]

[commentary This proposal does not include any classes that satisfy [link
requirements.io_control_command `IoControlCommand`] requirements. However,
implementation-specific extensions such as QoS may be implemented using
`ioctl()`, and the `io_control()` operation is included to allow these
extensions to be supported.]

  error_code bind(implementation_type& impl,
                  const endpoint_type& endpoint, error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to `error::bad_descriptor`. Otherwise binds the socket `impl` to the specified local endpoint, as
if by __POSIX__ __bind__.]

[function_returns `ec`.]

  error_code listen(implementation_type& impl, int backlog,
                    error_code& ec);

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwse marks the socket acceptor `impl` as ready to
accept connections, as if by __POSIX__ __listen__. If `backlog ==
socket_base::max_connections`, the implementation shall set the socket
acceptor's listen queue to the maximum allowable length.]

[function_returns `ec`.]

  endpoint_type local_endpoint(const implementation_type& impl,
                               error_code& ec) const;

[function_requires `is_open(impl)`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. Otherwise determines the locally-bound endpoint
associated with the socket acceptor `impl`, as if by __POSIX__
__getsockname__.]

[function_returns On success, the locally-bound endpoint associated with
`impl`. Otherwise `endpoint_type()`.]

  template<class SocketService>
    error_code accept(implementation_type& impl,
                      basic_socket<Protocol, SocketService>& socket,
                      endpoint_type* endpoint, error_code& ec);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects If `is_open(impl)` is false, sets `ec` to
`error::bad_descriptor`. If `socket.is_open()` is true, sets `ec` to
`error::already_open`. Otherwise associates `socket` with the first connection
extracted from the queue of pending connections of the socket acceptor `impl`,
as if by __POSIX__ __accept__. On success, and if `endpoint != 0`, and if
`endpoint != 0`, assigns into `*endpoint` the remote endpoint of the
connection.]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted. [inline_note Such as
__POSIX__ `ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or
`ERROR_NETNAME_DELETED`).]]

[function_returns `ec`.]

[function_postconditions `socket.is_open()`.]

  template<class SocketService, class AcceptHandler>
    void async_accept(implementation_type& impl,
                      basic_socket<Protocol, SocketService>& socket,
                      endpoint_type* endpoint, AcceptHandler handler);

[function_requires `is_open(impl) && !socket.is_open()`, and a prior call to
`listen` for the socket acceptor implementation `impl`.]

[function_effects Initiates an asynchronous operation to associate `socket`
with the first connection extracted from the queue of pending connections of
the socket acceptor `impl`, as if by __POSIX__ __accept__. The operation is
performed via the `io_service` object returned by
`io_service::service::io_service()` and behaves according to [link
requirements.asynchronous_operations asynchronous operation] requirements.]

[function_block If `is_open(impl)` is false, the operation shall fail
immediately with `error_code` value `error::bad_descriptor`. If
`socket.is_open()` is true, the operation shall fail immediately with
`error_code` value `error::already_open`.]

[function_block The program must ensure the `basic_socket<>` object `socket` is
valid until the handler for the asynchronous operation is invoked. If `endpoint
!= 0`, the program must ensure the object `*endpoint` is valid until the
handler for the asynchronous operation is invoked.]

[function_block Implementations shall not permit the operation to complete with
an error indicating that a connection has been aborted. [inline_note Such as
__POSIX__ `ECONNABORTED`, and __Windows__ `WSAECONNABORTED` or
`ERROR_NETNAME_DELETED`).]]

[endsect]

[endsect]
