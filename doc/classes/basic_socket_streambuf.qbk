[section:basic_socket_streambuf Class template [^basic_socket_streambuf]]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template <class Protocol, class Clock, class WaitTraits>
        class basic_socket_streambuf :
          public basic_streambuf<char>,
          public basic_socket<Protocol>
        {
        public:
          // types:

          typedef typename Protocol::endpoint endpoint_type;
          typedef typename Clock::time_point time_point;
          typedef typename Clock::duration duration;

          // construct / destroy:

          basic_socket_streambuf();
          virtual ~basic_socket_streambuf();

          // members:

          basic_socket_streambuf<Protocol>* connect(const endpoint_type& e);
          template<class... Args>
            basic_socket_streambuf<Protocol>* connect(Args&&... );

          basic_socket_streambuf<Protocol>* close();

          error_code error() const;

          time_point expiry() const;
          void expires_at(const time_point& t);
          void expires_after(const duration& d);

        protected:
          // overridden virtual functions:
          virtual int_type underflow();
          virtual int_type pbackfail(int_type c = traits_type::eof());
          virtual int_type overflow(int_type c = traits_type::eof());
          virtual int sync();
          virtual streambuf* setbuf(char_type* s, streamsize n);

        private:
          error_code ec_; // ``['exposition only]``
          time_point expiry_; // ``['exposition only]``
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

The class `basic_socket_streambuf<Protocol>` associates both the input sequence
and the output sequence with a socket. The input and output sequences are
independent and do not support seeking. Multibyte/wide character conversion is
not supported.

[section [^basic_socket_streambuf] constructors]

  basic_socket_streambuf();

[function_effects Constructs an object of class
`basic_socket_streambuf<Protocol>`, initialising the base classes with
`basic_streambuf<char>()` and `basic_socket<Protocol>(ios)`, where `ios` is an
unspecified object of class `io_service` that has a longer lifetime than the
`basic_socket<Protocol>` base.]

[function_postconditions `expiry() == Clock::max()`.]

  virtual ~basic_socket_streambuf();

[function_effects Destroys an object of class
`basic_socket_streambuf<Protocol>`. If a put area exists, calls
`overflow(traits_type::eof())` to flush characters. [inline_note The socket is
closed by the `basic_socket<Protocol>` destructor.]]

[endsect]

[section [^basic_socket_streambuf] members]

  basic_socket_streambuf<Protocol>* connect(const endpoint_type& e);

[function_effects Resets the `streambuf` get and put areas, closes the socket
as if by calling `basic_socket<Protocol>::close(ec_)`, then establishes a
connection as if by performing:
``
  basic_socket<Protocol>::async_connect(e, __unspecified__);
``
`ec_` is set to reflect the error code produced by the operation. If the
operation does not complete before the absolute timeout specified by
`expiry_`, the socket is closed and `ec_` is set to
`errc::operation_canceled`.]

[function_returns if `!ec_`, `this`; otherwise, a null pointer.]

  template<class... Args>
    basic_socket_streambuf<Protocol>* connect(Args&&... args);

[function_requires The `Protocol` type must meet the requirements for an [link
requirements.internet_protocol internet protocol].]

[function_effects Resets the `streambuf` get and put areas. Constructs an
object `q` of type `Protocol::resolver::query` by initialising the object with
`q(forward<Args>(args)__dotdotdot__)`, then establishes a connection as if by
performing:
``
  typename Protocol::resolver resolver(this->get_io_service());
  typename Protocol::resolver::iterator i = resolver.resolve(q, ec_);
  if (!ec_)
    std::experimental::network_v1::async_connect(*this, i, __unspecified__);
``
`ec_` is set to reflect the error code produced by the asynchronous operation.
If the operation does not complete before the absolute timeout specified by
`expiry_`, the socket is closed and `ec_` is set to
`errc::operation_canceled`.]

[function_returns if `!ec_`, `this`; otherwise, a null pointer.]

  basic_socket_streambuf<Protocol>* close();

[function_effects If a put area exists, calls `overflow(traits_type::eof())` to
flush characters. Calls:
``
  this->basic_socket<Protocol>::close(ec_);
``
then resets the get and put areas. If the call to `overflow` fails, or if `!ec_`,
then `close` fails.]

[function_returns `this` on success, a null pointer otherwise.]

  error_code error() const;

[function_returns `ec_`.]

  time_point expiry() const;

[function_returns `expiry_`.]

  void expires_at(const time_point& t);

[function_postconditions `expiry_ == t`.]

  void expires_after(const duration& d);

[function_effects Calls `expires_at(Clock::now() + d)`.]

[endsect]

[section [^basic_socket_streambuf] overridden virtual functions]

  virtual int_type underflow();

[function_effects Behaves according to the description of
`basic_streambuf<char>::underflow()`, with the specialisation that a sequence
of characters is read from the input sequence as if by __POSIX__ __recvmsg__,
and `ec_` is set to reflect the error code produced by the operation. If the
operation does not complete before the absolute timeout specified by `expiry_`,
the socket is closed and `ec_` is set to `errc::operation_canceled`.]

[function_effects Returns `traits_type::eof()` to indicate failure. Otherwise
returns `traits_type::to_int_type(*gptr())`.]

  virtual int_type pbackfail(int_type c = traits_type::eof());

[function_effects Puts back the character designated by `c` to the input
sequence, if possible, in one of three ways:\n
\n
[mdash] If `traits_type::eq_int_type(c,traits_type::eof())` returns `false`,
and if the function makes a putback position available, and if
`traits_type::eq(traits_type::to_char_type(c),gptr()[-1])` returns `true`,
decrements the next pointer for the input sequence, `gptr()`.\nReturns: `c`.\n
\n
[mdash] If `traits_type::eq_int_type(c,traits_type::eof())` returns `false`,
and if the function makes a putback position available, and if the function is
permitted to assign to the putback position, decrements the next pointer for
the input sequence, and stores `c` there.\nReturns: `c`.\n
\n
[mdash] If `traits_type::eq_int_type(c,traits_type::eof())` returns `true`, and
if either the input sequence has a putback position available or the function
makes a putback position available, decrements the next pointer for the input
sequence, `gptr()`.\nReturns: `traits_type::not_eof(c)`.]

[function_returns `traits_type::eof()` to indicate failure.]

[function_notes The function does not put back a character directly to the
input sequence. If the function can succeed in more than one of these ways, it
is unspecified which way is chosen. The function can alter the number of
putback positions available as a result of any call.]

  virtual int_type overflow(int_type c = traits_type::eof());

[function_effects Behaves according to the description of
`basic_streambuf<char>::overflow(c)`, except that the behaviour of "consuming
characters" is performed by output of the characters to the socket as if by one
or more calls to __POSIX__ __sendmsg__, and `ec_` is set to reflect the error
code produced by the operation. If the operation does not complete before the
absolute timeout specified by `expiry_`, the socket is closed and `ec_` is set
to `errc::operation_canceled`.]

[function_returns `traits_type::not_eof(c)` to indicate success, and
`traits_type::eof()` to indicate failure.]

  virtual int sync();

[function_effects If a put area exists, calls `overflow(traits_type::eof())` to
flush characters.]

  virtual streambuf* setbuf(char_type* s, streamsize n);

[function_effects If `setbuf(0,0)` is called on a stream before any I/O has
occurred on that stream, the stream becomes unbuffered. Otherwise the results
are unspecified. "Unbuffered" means that `pbase()` and `pptr()` always return
null and output to the socket should appear as soon as possible.]

[endsect]

[endsect]
