[section:basic_fifobuf Class template [^basic_fifobuf]]

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Allocator = std::allocator<char> >
        class basic_fifobuf :
          public streambuf
        {
        public:
          // types:
          typedef Allocator allocator_type;
          typedef ``['unspecified]`` const_buffers_type;
          typedef ``['unspecified]`` mutable_buffers_type;

          // constructors:
          explicit basic_fifobuf(
            size_t max_sz = numeric_limits<size_t>::max(),
            const Allocator& alloc = Allocator());

          // members:
          allocator_type get_allocator() const;
          size_t size() const;
          size_t max_size() const;
          const_buffers_type data() const;
          mutable_buffers_type prepare(size_t n);
          void commit(size_t n);
          void consume(size_t n);

        protected:
          // overridden virtual functions:
          virtual int_type underflow();
          virtual int_type pbackfail(int_type c = traits_type::eof());
          virtual int_type overflow(int_type c = traits_type::eof());

        private:
          basic_fifobuf(const basic_fifobuf&);   // not defined
          void operator=(const basic_fifobuf&);  // not defined
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

The class `basic_fifobuf` is derived from `basic_streambuf` to associate the
input sequence and output sequence with one or more objects of some character
array type, whose elements store arbitrary values. These character array
objects are internal to the `basic_fifobuf` object, but direct access to the
array elements is provided to permit them to be used with I/O operations, such
as the `send` or `receive` operations of a socket. Characters written to the
output sequence of a `basic_fifobuf` object are appended to the input sequence
of the same object.

The class `basic_fifobuf` permits the following implementation strategies:

* A single contiguous character array, which is reallocated as necessary to
  accommodate changes in the size of the character sequence.

* A sequence of one or more character arrays, where each array is of the same
  size. Additional character array objects are appended to the sequence to
  accommodate changes in the size of the character sequence.

* A sequence of one or more character arrays of varying sizes. Additional
  character array objects are appended to the sequence to accommodate changes
  in the size of the character sequence.

The constructor for `basic_fifobuf` accepts a `size_t` argument specifying the
maximum of the sum of the sizes of the input sequence and output sequence.
During the lifetime of the `fifobuf` object, the invariant `size() <=
max_size()` shall hold. Any member function that would, if successful, cause
the invariant to be violated shall throw an exception of class `length_error`.

The constructor for `basic_fifobuf` takes an `Allocator&` argument. A copy of
this argument is used for any memory allocation performed, by the constructor
and by all member functions, during the lifetime of each `fifobuf` object.

[std_example Writing directly from a `fifobuf` to a socket:..
``
  fifobuf b;
  std::ostream os(&b);
  os << "Hello, World!\n";

  // try sending all data in input sequence
  size_t n = sock.send(b.data());

  b.consume(n); // sent data is removed from input sequence
``]

[std_example Reading from a socket directly into a `fifobuf`:..
``
  fifobuf b;

  // reserve 512 bytes in output sequence
  fifobuf::const_buffers_type bufs = b.prepare(512);

  size_t n = sock.receive(bufs);

  // received data is "committed" from output sequence to input sequence
  b.commit(n);

  std::istream is(&b);
  std::string s;
  is >> s;
``]

[section [^basic_fifobuf] constructors]

  explicit basic_fifobuf(
    size_t max_sz = numeric_limits<size_t>::max(),
    const Allocator& alloc = Allocator());

[function_effects Constructs an object of class `basic_fifobuf<Allocator>`.]

[function_postconditions The postconditions of this function are indicated in
the table below.]

[table basic_fifobuf<Allocator>::basic_fifobuf(size_t, const Allocator&) effects
  [[expression][value]]
  [
    [`size()`]
    [`0`]
  ]
  [
    [`max_size()`]
    [`max_sz`]
  ]
  [
    [`get_allocator()`]
    [`alloc`]
  ]
]

[endsect]

[section [^basic_fifobuf] members]

  size_t size() const;

[function_returns The size of the input sequence. The value shall be equal to
that calculated for `s` in the following code.
``
  size_t s = 0;
  const_buffers_type bufs = data();
  const_buffers_type::const_iterator i = bufs.begin();
  while (i != bufs.end())
  {
    const_buffer buf(*i++);
    s += buffer_size(buf);
  }
``]

[function_complexity Constant time. [inline_note This implies that an
implementation based on non-contiguous character array objects must cache the
size of all array objects that are part of the input sequence.]]

  allocator_type get_allocator() const;

[function_returns A copy of the `Allocator` object used to construct the
`fifobuf`.]

  size_t max_size() const;

[function_returns The allowed maximum of the sum of the sizes of the input
sequence and output sequence.]

  const_buffers_type data() const;

[function_returns An object of type `const_buffers_type` that satisfies [link
requirements.const_buffers `ConstBufferSequence`] requirements, representing all
character array objects in the input sequence. The returned object is
invalidated by any `fifobuf` member function that modifies the input sequence
or output sequence.]

  mutable_buffers_type prepare(size_t n);

[function_requires `size() + n <= max_size()`.]

[function_effects Ensures that the output sequence can accommodate `n`
characters, reallocating character array objects as necessary.]

[function_returns An object of type `mutable_buffers_type` that satisfies [link
requirements.mutable_buffers `MutableBufferSequence`] requirements, representing
character array objects at the start of the output sequence such that the sum
of the buffer sizes is `n`. The returned object is invalidated by any `fifobuf`
member function that modifies the input sequence or output sequence.]

[function_throws `length_error` if `size() + n > max_size()`.]

  void commit(size_t n);

[function_requires A preceding call `prepare(x)` where `x >= n`, and no
intervening operations that modify the input or output sequence.]

[function_effects Appends `n` characters from the start of the output sequence
to the input sequence. The beginning of the output sequence is advanced by `n`
characters.]

[function_throws `length_error` if `n` is greater than the size of the output
sequence.]

  void consume(size_t n);

[function_requires `n <= size()`.]

[function_effects Removes `n` characters from the beginning of the input
sequence.]

[function_throws `length_error` if `n > size()`.]

[endsect]

[section [^basic_fifobuf] overridden virtual functions]

  virtual int_type underflow();

[function_effects Behaves according to the description of
`basic_streambuf<char>::underflow()`.]

  virtual int_type pbackfail(int_type c = traits_type::eof());

[function_requires `size() < max_size()`.]

[function_effects Behaves according to the description of
`basic_streambuf<char>::pbackfail()`, with the specialisation that
`length_error` is thrown if prepending the character to the input sequence
would require the condition `size() > max_size()` to be true.]

  virtual int_type overflow(int_type c = traits_type::eof());

[function_requires `traits_type::eq_int_type(c, traits_type::eof()) || size() <
max_size()`.]

[function_effects Behaves according to the description of
`basic_streambuf<char>::overflow()`, with the specialisation that
`length_error` is thrown if appending the character to the input sequence would
require the condition `size() > max_size()` to be true.]

[endsect]

[endsect]
