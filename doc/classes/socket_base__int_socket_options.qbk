[section:socket_base__int_socket_options Integral socket options]
[xrefid socket.opt.int]

The `socket_base::receive_buffer_size`, `socket_base::receive_low_watermark`,
`socket_base::send_buffer_size` and `socket_base::send_low_watermark` classes
are integral socket options.

Integral socket option classes satisfy the requirements for `Destructible` (C++
Std, [destructible]), `CopyConstructible` (C++ Std, [copyconstructible]),
`Assignable` (C++ Std, [assignable]), [link requirements.gettable_socket_option
`GettableSocketOption`], and [link requirements.settable_socket_option
`SettableSocketOption`].

Integral socket option classes are defined as follows:

  class ``['[*C]]``
  {
  public:
    // constructors:
    ``['[*C]]``() noexcept;
    explicit ``['[*C]]``(int v);

    // members:
    ``['[*C]]``& operator=(int v);

    int value() const noexcept;
  };

Extensible implementations provide the following member functions:

  class ``['[*C]]``
  {
  public:
    template<class Protocol> int level(const Protocol& p) const noexcept;
    template<class Protocol> int name(const Protocol& p) const noexcept;
    template<class Protocol> void* data(const Protocol& p) noexcept;
    template<class Protocol> const void* data(const Protocol& p) const noexcept;
    template<class Protocol> size_t size(const Protocol& p) const noexcept;
    template<class Protocol> void resize(const Protocol& p, size_t s);
    // ``['remainder unchanged]``
  private:
    int value_; // ``['exposition only]``
  };

Let [^['L]] and [^['N]] identify the __POSIX__ macros to be passed as the
/level/ and /option_name/ arguments, respectively, to __POSIX__ __setsockopt__
and __getsockopt__.

[table Integral socket options
  [[['C]][['L]][['N]][Definition or notes]]
  [
    [`socket_base::receive_buffer_size`]
    [`SOL_SOCKET`]
    [`SO_RCVBUF`]
    [
      Specifies the size of the receive buffer associated with a socket.
    ]
  ]
  [
    [`socket_base::receive_low_watermark`]
    [`SOL_SOCKET`]
    [`SO_RCVLOWAT`]
    [
      Specifies the minimum number of bytes to process for socket input
      operations.
    ]
  ]
  [
    [`socket_base::send_buffer_size`]
    [`SOL_SOCKET`]
    [`SO_SNDBUF`]
    [
      Specifies the size of the send buffer associated with a socket.
    ]
  ]
  [
    [`socket_base::send_low_watermark`]
    [`SOL_SOCKET`]
    [`SO_SNDLOWAT`]
    [
      Specifies the minimum number of bytes to process for socket output
      operations.
    ]
  ]
]

[std_note The constants `SOL_SOCKET`, `SO_RCVBUF`, `SO_RCVLOWAT`, `SO_SNDBUF`
and `SO_SNDLOWAT` are defined in the __POSIX__ header file __sys_socket_h__.]

[section Integral socket option constructors]
[xrefid socket.opt.int.cons]

  ``['[*C]]``() noexcept;

[function_postconditions `value() == 0`.]

  explicit ``['[*C]]``(int v);

[function_postconditions `value() == v`.]

[endsect]

[section Integral socket option members]
[xrefid socket.opt.int.members]

  ``['[*C]]``& operator=(int v);

[function_returns `*this`.]

[function_postconditions `value() == v`.]

  int value() const noexcept;

[function_returns The stored socket option value. For extensible
implementations, returns `value_`.]

[endsect]

[section Integral socket option members (extensible implementations)]
[xrefid socket.base.int.extensible]

  template<class Protocol> int level(const Protocol& p) const noexcept;

[function_returns ['[*`L`]].]

  template<class Protocol> int name(const Protocol& p) const noexcept;

[function_returns ['[*`N`]].]

  template<class Protocol> void* data(const Protocol& p) noexcept;

[function_returns `std::addressof(value_)`.]

  template<class Protocol> const void* data(const Protocol& p) const noexcept;

[function_returns `std::addressof(value_)`.]

  template<class Protocol> size_t size(const Protocol& p) const noexcept;

[function_returns `sizeof(value_)`.]

  template<class Protocol> void resize(const Protocol& p, size_t s);

[function_throws `length_error` if `s` is not a valid data size for the
protocol specified by `p`.]
  
[endsect]

[endsect]
