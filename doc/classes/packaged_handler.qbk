[section:packaged_handler Class template [^packaged_handler]]
[xrefid async.package.handler]

Class template `packaged_handler` is an adapter to enable the use of packaged
tasks with asynchronous operations as a completion handler with an associated
allocator.

  namespace std {
    namespace experimental {
      __begin_versioned_ns__

        template<class, class> class packaged_handler; // undefined

        template<class R, class... Args, class ProtoAllocator>
        class packaged_handler<R(Args...), ProtoAllocator>
        {
        public:
          // packaged_handler types:

          typedef ProtoAllocator allocator_type;

          // packaged_handler construct / copy / assign:

          template<class Func>
            explicit packaged_handler(packaged_token<Func, ProtoAllocator>&& token);
          packaged_handler(const packaged_handler&) = delete;
          packaged_handler(packaged_handler&& rhs) noexcept;
          packaged_handler& operator=(const packaged_handler&) = delete;
          packaged_handler& operator=(packaged_handler&& rhs) noexcept;

          // packaged_handler operations:

          allocator_type get_allocator() const noexcept;
          future<R> get_future();
          void operator()(Args... args);

        private:
          packaged_task<R(Args...)> task_; // ``['exposition only]``
          ProtoAllocator allocator_; // ``['exposition only]``
        };

        template<class Signature, class ProtoAllocator>
          class async_result<packaged_handler<Signature, ProtoAllocator>>;

      __end_versioned_ns__
    } // namespace experimental
  } // namespace std

[section [^packaged_handler] members]
[xrefid async.package.handler.members]

  template<class Func>
    explicit packaged_handler(packaged_token<Func, ProtoAllocator>&& token);

[function_effects Initializes `task_` with `std::move(token.f_)` and
initializes `allocator_` with `token.allocator_`.]

  packaged_handler(packaged_handler&& rhs) noexcept;

[function_effects Initializes `task_` with `std::move(rhs.task_)` and
initializes `allocator_` with `std::move(rhs.allocator_)`.]

  packaged_handler& operator=(packaged_handler&& rhs) noexcept;

[function_effects Performs `task_ = std::move(rhs.task_)` and
`allocator_ = std::move(rhs.allocator_)`.]

[function_returns `*this`.]

  allocator_type get_allocator() const noexcept;

[function_returns `allocator_`.]

  future<R> get_future();

[function_returns `task_.get_future()`.]

  void operator()(Args... args);

[function_effects Calls `task_(forward<Args>(args)__dotdotdot__)`.]

[endsect]

[section:async_result_packaged_handler Partial class template specialization [^async_result]]
[xrefid async.package.handler.async.result]

  namespace std {
    namespace experimental {
      __begin_versioned_ns__

        template<class R, class... Args, class ProtoAllocator>
        class async_result<packaged_handler<R(Args...), ProtoAllocator>>
        {
        public:
          typedef future<R> type;

          explicit async_result(packaged_task<R(Args...)>& t);
          async_result(const async_result&) = delete;
          async_result& operator=(const async_result&) = delete;

          type get();

        private:
          type future_; // ``['exposition only]``
        };

      __end_versioned_ns__
    } // namespace experimental
  } // namespace std

The implementation provides a partial specialization of `async_result` that
meets the [link classes.async_result `async_result` specialization
requirements].

  explicit async_result(packaged_handler<Signature, ProtoAllocator>& h);

[function_effects Initializes `future_` with `t.get_future()`.]

  type get();

[function_returns `std::move(future_)`.]

[endsect]

[endsect]
