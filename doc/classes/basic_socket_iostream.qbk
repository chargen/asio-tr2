[section:basic_socket_iostream Class template [^basic_socket_iostream]]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template<class Protocol, class Clock, class WaitTraits>
        class basic_socket_iostream :
          public basic_iostream<char>
        {
        public:
          // types:

          typedef typename Protocol::endpoint endpoint_type;
          typedef typename Clock::time_point time_point;
          typedef typename Clock::duration duration;

          // constructors:

          basic_socket_iostream();
          template<class... Args>
            explicit basic_socket_iostream(Args&&... args);

          // members:

          template<class... Args> void connect(Args&&... args);

          void close();

          basic_socket_streambuf<Protocol, StreamSocketService>* rdbuf() const;

          error_code error() const;

          time_point expiry() const;
          void expires_at(const time_point& t);
          void expires_after(const duration& d);

        private:
          basic_socket_streambuf<Protocol,
            Clock, WaitTraits> sb_; // ``['exposition only]``
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

The class template `basic_socket_iostream<Protocol, Clock, WaitTraits>`
supports reading and writing from sockets. It uses a
`basic_socket_streambuf<Protocol, Clock, WaitTraits>` object to control the
associated sequences. For the sake of exposition, the maintained data is
presented here as:

[mdash] `sb_`, the `basic_socket_streambuf` object.

[section [^basic_socket_iostream] constructors]

  basic_socket_iostream();

[function_effects Constructs an object of class
`basic_socket_iostream<Protocol, Clock, WaitTraits>`, initialising the base
class with `basic_iostream<char>(&sb_)`, initialising `sb_` with
`basic_socket_streambuf<Protocol, Clock, WaitTraits>()`, and performing
`this->setf(std::ios_base::unitbuf)`.]

  template<class... Args>
    explicit basic_socket_iostream(Args&&... args);

[function_effects Constructs an object of class
`basic_socket_iostream<Protocol, Clock, WaitTraits>`, initialising the base
class with `basic_iostream<char>(&sb_)` initialising `sb_` with
`basic_socket_streambuf<Protocol, Clock, WaitTraits>()`, and performing
`this->setf(std::ios_base::unitbuf)`. Then calls
`rdbuf()->connect(forward<Args>(args)__dotdotdot__)`. If that function returns
a null pointer, calls `setstate(failbit)`.]

[endsect]

[section [^basic_socket_iostream] members]

  template<class... Args>
    void connect(Args&&... args);

[function_effects Calls `rdbuf()->connect(forward<Args>(args)__dotdotdot__)`.
If that function returns a null pointer, calls `setstate(failbit)` (which may
throw `ios_base::failure`).]

  void close();

[function_effects Calls `rdbuf()->close()`. If that function returns a null
pointer, calls `setstate(failbit)` (which may throw `ios_base::failure`).]

  basic_socket_streambuf<Protocol, StreamSocketService>* rdbuf() const;

[function_returns `const_cast<basic_socket_streambuf<Protocol, Clock,
WaitTraits>*>(&sb_)`.]

  error_code error() const;

[function_returns `rdbuf()->error()`.]

  time_point expiry() const;

[function_returns `rdbuf()->expiry()`.]

  void expires_at(const time_point& t);

[function_effects Calls `rdbuf()->expires_at(t)`.]

  void expires_after(const duration& d);

[function_effects Calls `rdbuf()->expires_after(d)`.]

[endsect]

[endsect]
