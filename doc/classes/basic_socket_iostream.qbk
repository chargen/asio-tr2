[section:basic_socket_iostream Class template [^basic_socket_iostream]]

  namespace std {
    namespace tr2 {
      namespace sys {

        template<class Protocol, class StreamSocketService>
        class basic_socket_iostream :
          public basic_iostream<char>
        {
        public:
          // constructors:
          basic_socket_iostream();
          template<class T1, class T2, ..., class TN>
            explicit basic_socket_iostream(T1 t1, T2 t2, ..., TN tN);

          // members:
          template<class T1, class T2, ..., class TN>
            void connect(T1 t1, T2 t2, ..., TN tN);

          void close();

          basic_socket_streambuf<Protocol, StreamSocketService>* rdbuf() const;

        private:
  //      basic_socket_streambuf<Protocol,
  ``//        StreamSocketService> sb;        ['[*exposition only]]``
        };

      } // namespace sys
    } // namespace tr2
  } // namespace std

The class template `basic_socket_iostream<Protocol, StreamSocketService>`
supports reading and writing from sockets. It uses a
`basic_socket_streambuf<Protocol, StreamSocketService>` object to control the
associated sequences. For the sake of exposition, the maintained data is
presented here as:

[mdash] `sb`, the `basic_socket_streambuf` object.

[section [^basic_socket_iostream] constructors]

  basic_socket_iostream();

[function_effects Constructs an object of class
`basic_socket_iostream<Protocol, StreamSocketService>`, initialising the base
class with `basic_iostream<char>(&sb)` and initialising `sb` with
`basic_socket_streambuf<Protocol, StreamSocketService>()`.]

[function_postconditions `tie() == this`.]

  template<class T1, class T2, ..., class TN>
    explicit basic_socket_iostream(T1 t1, T2 t2, ..., TN tN);

[function_effects Constructs an object of class
`basic_socket_iostream<Protocol, StreamSocketService>`, initialising the base
class with `basic_iostream<char>(&sb)` and initialising `sb` with
`basic_socket_streambuf<Protocol, StreamSocketService>()`. Then calls
`rdbuf()->connect(t1, t2, __dotdotdot__, tN)`. If that function returns a null
pointer, calls `setstate(failbit)`.]

[function_postconditions `tie() == this`.]

[endsect]

[section [^basic_socket_iostream] members]

  template<class T1, class T2, ..., class TN>
    void connect(T1 t1, T2 t2, ..., TN tN);

[function_effects Calls `rdbuf()->connect(t1, t2, __dotdotdot__, tN)`. If that
function returns a null pointer, calls `setstate(failbit)` (which may throw
`ios_base::failure`).]

  void close();

[function_effects Calls `rdbuf()->close()`. If that function returns a null
pointer, calls `setstate(failbit)` (which may throw `ios_base::failure`).]

  basic_socket_streambuf<Protocol, StreamSocketService>* rdbuf() const;

[function_returns `const_cast<basic_socket_streambuf<Protocol,
StreamSocketService>*>(&sb)`.]

[endsect]

[endsect]
