[section:basic_deadline_timer Class template [^basic_deadline_timer]]

  namespace std {
    namespace experimental {
      inline namespace network_v1 {

        template<class Time, class TimeTraits, class TimerService>
        class basic_deadline_timer :
          public basic_io_object<TimerService>
        {
        public:
          // types:
          typedef TimeTraits traits_type;
          typedef Time time_type;
          typedef typename TimeTraits::duration_type duration_type;

          // constructors:
          explicit basic_deadline_timer(io_service& ios);
          basic_deadline_timer(io_service& ios, const time_type& t);
          basic_deadline_timer(io_service& ios, const duration_type& d);

          // members:
          size_t cancel();
          size_t cancel(error_code& ec);

          time_type expires_at() const;

          size_t expires_at(const time_type& t);
          size_t expires_at(const time_type& t, error_code& ec);

          duration_type expires_from_now() const;

          size_t expires_from_now(const duration_type& d);
          size_t expires_from_now(const duration_type& d, error_code& ec);

          void wait();
          void wait(error_code& ec);

          template <class WaitHandler>
            void async_wait(WaitHandler handler);
        };

      } // inline namespace network_v1
    } // namespace experimental
  } // namespace std

[section [^basic_deadline_timer] constructors]

  explicit basic_deadline_timer(io_service& ios);

[function_effects Constructs an object of class `basic_deadline_timer<Time,
TimeTraits, TimerService>`, initialising the base class with
`basic_io_object(ios)`.]

  basic_deadline_timer(io_service& ios, const time_type& t);

[function_effects Constructs an object of class `basic_deadline_timer<Time,
TimeTraits, TimerService>`, initialising the base class with
`basic_io_object(ios)`, then setting the expiry time as if by calling:
``
  error_code ec;
  this->service.expires_at(this->implementation, t, ec);
  if (ec) throw system_error(ec);
``]

  basic_deadline_timer(io_service& ios, const duration_type& d);

[function_effects Constructs an object of class `basic_deadline_timer<Time,
TimeTraits, TimerService>`, initialising the base class with
`basic_io_object(ios)`, then setting the expiry time as if by calling:
``
  error_code ec;
  this->service.expires_from_now(this->implementation, d, ec);
  if (ec) throw system_error(ec);
``]

[endsect]

[section [^basic_deadline_timer] members]

  size_t cancel();
  size_t cancel(error_code& ec);

[function_returns `this->service.cancel(this->implementation, ec)`.]

  time_type expires_at() const;

[function_returns `this->service.expires_at(this->implementation)`.]

  size_t expires_at(const time_type& t);
  size_t expires_at(const time_type& t, error_code& ec);

[function_returns `this->service.expires_at(this->implementation, t, ec)`.]

  duration_type expires_from_now() const;

[function_returns `this->service.expires_from_now(this->implementation)`.]

  size_t expires_from_now(const duration_type& d);
  size_t expires_from_now(const duration_type& d, error_code& ec);

[function_returns `this->service.expires_from_now(this->implementation, d, ec)`.]

  void wait();
  void wait(error_code& ec);

[function_effects Calls `this->service.wait(this->implementation, ec)`.]

  template <class WaitHandler>
    void async_wait(WaitHandler handler);

[function_effects Calls `this->service.async_wait(this->implementation,
handler)`.]

[endsect]

[endsect]
