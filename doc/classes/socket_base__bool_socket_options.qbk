[section:socket_base__bool_socket_options Boolean socket options]
[xrefid socket.opt.bool]

The `socket_base::broadcast`, `socket_base::debug`,
`socket_base::do_not_route`, `socket_base::keep_alive`,
`socket_base::out_of_band_inline` and `socket_base::reuse_address` classes are
boolean socket options.

Boolean socket option classes satisfy the requirements for `Destructible`
(C++Std [destructible]), `CopyConstructible` (C++Std [copyconstructible]),
`CopyAssignable` (C++Std [copyassignable]), [link
requirements.gettable_socket_option `GettableSocketOption`], and [link
requirements.settable_socket_option `SettableSocketOption`]. The boolean socket
option classes are contextually convertible to bool.

Boolean socket option classes are defined as follows:

  class ``['[*C]]``
  {
  public:
    // constructors:
    ``['[*C]]``() noexcept;
    explicit ``['[*C]]``(bool v) noexcept;

    // members:
    ``['[*C]]``& operator=(bool v) noexcept;

    bool value() const noexcept;

    explicit operator bool() const noexcept;
    bool operator!() const noexcept;
  };

Extensible implementations provide the following member functions:

  class ``['[*C]]``
  {
  public:
    template<class Protocol> int level(const Protocol& p) const noexcept;
    template<class Protocol> int name(const Protocol& p) const noexcept;
    template<class Protocol> void* data(const Protocol& p) noexcept;
    template<class Protocol> const void* data(const Protocol& p) const noexcept;
    template<class Protocol> size_t size(const Protocol& p) const noexcept;
    template<class Protocol> void resize(const Protocol& p, size_t s);
    // ``['remainder unchanged]``
  private:
    int value_; // ``['exposition only]``
  };

Let [^['L]] and [^['N]] identify the __POSIX__ macros to be passed as the
/level/ and /option_name/ arguments, respectively, to __POSIX__ __setsockopt__
and __getsockopt__.

[table Boolean socket options
  [[['C]][['L]][['N]][Definition or notes]]
  [
    [`socket_base::broadcast`]
    [`SOL_SOCKET`]
    [`SO_BROADCAST`]
    [
      Determines whether a socket permits sending of broadcast messages, if
      supported by the protocol.
    ]
  ]
  [
    [`socket_base::debug`]
    [`SOL_SOCKET`]
    [`SO_DEBUG`]
    [
      Determines whether debugging information is recorded by the underlying
      protocol.
    ]
  ]
  [
    [`socket_base::do_not_route`]
    [`SOL_SOCKET`]
    [`SO_DONTROUTE`]
    [
      Determines whether outgoing messages bypass standard routing facilities.
    ]
  ]
  [
    [`socket_base::keep_alive`]
    [`SOL_SOCKET`]
    [`SO_KEEPALIVE`]
    [
      Determines whether a socket permits sending of keep_alive messages, if
      supported by the protocol.
    ]
  ]
  [
    [`socket_base::out_of_band_inline`]
    [`SOL_SOCKET`]
    [`SO_OOBINLINE`]
    [
      Determines whether out-of-band data (also known as urgent data) is
      received inline.
    ]
  ]
  [
    [`socket_base::reuse_address`]
    [`SOL_SOCKET`]
    [`SO_REUSEADDR`]
    [
      Determines whether the validation of endpoints used for binding a socket
      should allow the reuse of local endpoints, if supported by the protocol.
    ]
  ]
]

[section Boolean socket option constructors]
[xrefid socket.opt.bool.cons]

  ``['[*C]]``() noexcept;

[function_postconditions `!value()`.]

  explicit ``['[*C]]``(bool v) noexcept;

[function_postconditions `value() == v`.]

[endsect]

[section Boolean socket option members]
[xrefid socket.opt.bool.members]

  ``['[*C]]``& operator=(bool v) noexcept;

[function_returns `*this`.]

[function_postconditions `value() == v`.]

  bool value() const noexcept;

[function_returns The stored socket option value. For extensible
implementations, returns `value_ != 0`.]

  explicit operator bool() const noexcept;

[function_returns `value()`.]

  bool operator!() const noexcept;

[function_returns `!value()`.]

[endsect]

[section Boolean socket option members (extensible implementations)]
[xrefid socket.opt.bool.extensible]

  template<class Protocol> int level(const Protocol& p) const noexcept;

[function_returns ['[*`L`]].]

  template<class Protocol> int name(const Protocol& p) const noexcept;

[function_returns ['[*`N`]].]

  template<class Protocol> void* data(const Protocol& p) noexcept;

[function_returns `std::addressof(value_)`.]

  template<class Protocol> const void* data(const Protocol& p) const noexcept;

[function_returns `std::addressof(value_)`.]

  template<class Protocol> size_t size(const Protocol& p) const noexcept;

[function_returns `sizeof(value_)`.]

  template<class Protocol> void resize(const Protocol& p, size_t s);

[function_throws `length_error` if `s` is not a valid data size for the
protocol specified by `p`.]
  
[endsect]

[endsect]
